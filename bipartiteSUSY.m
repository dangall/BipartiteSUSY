(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["BipartiteSUSY`"]

polytopeDim::usage="Takes a matrix as input and outputs the dimension of a polytope with vertices given the columns of that matrix"
joinupKasteleyn::usage="REMOVE ME FROM GLOBAL FUNCTIONS!"
totFaces::usage="Gives the TOTAL number of faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
externalFaces::usage="Gives the number of EXTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
internalFaces::usage="Gives the number of INTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
allFaceLabels::usage="Gives the name of the faces in the graph."
externalFaceLabels::usage="Gives the name of the EXTERNAL faces in the graph."
internalFaceLabels::usage="Gives the name of the INTERNAL faces in the graph."
reducibilityQ::usage="Tells you whether a graph is reducible, in the scattering amplitudes sense. Set the last argument equal to True to get reducibility in the \!\(\*SubscriptBox[\(BFT\), \(2\)]\) sense"
getWeightedAdjacencyMatrix::usage="Gives the weighted adjacency matrix which can be used for WeightedAdjacencyGraph"
getAdjacencyMatrix::usage="Gives the adjacency matrix which can be used for AdjacencyGraph"
planarityQ::usage="Tells you whether a given graph can be embedded on the disk without any edges crossing"
viewGraph::usage="Shows you the graph"
duplicateEdges::usage="Returns a list of edges not appearing in a correct way in the Kasteleyn"
edgesBFTformQ::usage="Tells you whether edges are of the correct form _[_Integer,_Integer]"
consistentKasteleyn::usage="Assuming that edgesBFTformQ returns True, this function will return the list of rows and columns whose index structure violates the rules for BFTs (clockwise around white nodes and counter-clockwise around black nodes)"
checkKasteleynQ::usage="Tells you whether the Kasteleyn was inputted correctly. Its final input is optional and says whether the graph is a BFT graph (with corresponding index structure) or not."
perfectMatchings::usage="Returns the sorted list of perfect matchings. Takes as optional input whether it should check the Kasteleyn for you, and whether the graph is a BFT graph."
getPmatrix::usage="Returns the P matrix. Rows are ordered lexicographically w.r.t. edge labeling, columns are ordered according to the order given by the perfectMatchings function"
intoPolytope::usage="Returns only distinct vertices of the polytope, with their multiplicity"
matroidPolytope::usage="Returns the coordinates of the matroid polytope (some of which may have higher multiplicity than 1). Each column is the coordinate of a perfect matching."
moduliSpaceBFT::usage="Gives the moduli space of the BFT given by the Kasteleyn. It requires the input on which gauging it should use (i.e. gauging 1 or gauging 2)."
lowNumberLoopsPM::usage="Returns the number of the perfect matching with lowest multiplicity, and hence the lowest number of loops in the corresponding perfect orientation."
externalOrderingDefault::usage="Gives a choice of external ordering of nodes, given in the form {X[i,j]\[Rule]1,X[k,l]\[Rule]2,...}."
findSources::usage="Returns a list of edges which are sources in the perfect orientation corresponding to a given reference perfect matching."
findSinks::usage="Returns a list of edges which are sinks in the perfect orientation corresponding to a given reference perfect matching."
externalEdgesNodeNumbers::usage="Takes a list of external edges and gives the Kasteleyn node numbers of the edges."
connectivityMatrix::usage="Returns the connectivity matrix of the diagram, i.e. a matrix containing all paths between all nodes."
pathMatrix::usage="Gives the path matrix, i.e. the element of the Grassmannian before any signs are placed (which ensure manifest positivity of planar diagrams)."
minorsAsPerfectMatchings::usage="Returns the minors of the pathmatrix, resembling Plucker coordinates of the Grassmannian, but without manifest-positivity signs."
dimensionGrassmannian::usage="Returns the dimension of the Grassmannian, computed by looking at the tangent space of its minors."
reducibilityBFTQ::usage="Gives the 'naive' reducibility of a graph, which is the same as the reducibility for a BFT, based on its moduli space. When gauging 2 is used, this is the same as reducibility for planar scattering diagrams."
reducibilityBFTedges::usage="Gives those edges which may be removed without affecting the moduli space, which for gauging 2 is the same as reducibility for all planar diagrams and some non-planar diagrams."
reducibilityQ::usage="Returns True or False, depending on whether the graph is reducible or not. Allows you to specify whether the graph is a BFTgraph, and if so which gaugign to use. Can correctly deal with non-planar scattering diagrams."
reducibilityEdges::usage="Returns a list of edges which may be removed without affecting the moduli space (in the case of BFTs), or the Grassmannian in the case of scattering amplitudes."
consistentEdgeRemoval::usage="Returns the full list of edges which should be consistently removed, given a choice of edge to be removed."
survivingPerfectMatchings::usage="Gives you a list of which perfect-matching numbers survive after removing a given set of edges."
reductionGraphBFT::usage="Returns a list where each element is a set of edges which may be removed from the graph without affecting the moduli space  (in the case of BFTs) under a certain guaging, or matroid polytope (in the case of scattering amplitudes)."
reductionGraph::usage="Returns the sets of edges which may be removed without changing any of the physics. Is valid both for BFTs as well as planar and non-planar on-shell diagrams."
nonPluckerPolesQ::usage="Tells you whether a reduced diagram has non-standard poles which are not simply products of Plucker coordinates."
removableEdges::usage="Returns the list of removable edges. If checkneeded=True, it will also check if the starting graph is reduced or not."
edgeOrderings::usage="Returns a list where each element is a consistent ordering of edges around a white or black node, i.e. where the edges are sequenced such that each subsequent edge's first index is equal to the previous edge's second index."
nextStepBlackToWhite::usage="Returns the next edge in the zig-zag path and its position."
nextStepWhiteToBlack::usage="Returns the next edge in the zig-zag path and its position."
internalZigZagNumeratorDenominator::usage="Returns a list where the first element is a list of edges in the numerator of a zig-zag path, and the second element is a list of edges in the denominator of the zig-zag path. The zig-zag path starts from an edge."
allZigZagNumeratorsDenominators::usage="Returns a list where each element corresponds to a zig-zag path. The information is given as a list of two elements, where the first element contains all variables in the numerator of the expression, and the second element contains the variables in the denominator. Assumes standard rules: turn left at white nodes and right at black nodes, and edges from white to black are in the numerator, and vice-versa."
makeZigZags::usage="Returns a list of zig-zag paths. Edges in the numerator are directed from white to black nodes, edges in the denominator are directed from black to white nodes. The standard rule is to turn left at white nodes and right at black nodes; it's possible to choose the opposite option by setting the (optional) final argument to True."
selfIntersectingZigZagsQ::usage="Tells you whether the graph has self-intersecting zig-zag paths. Returns True or False."
badDoubleCrossingZigZagPairs::usage="Returns a list of pairs of zig-zags that have 'bad double crossings'. Every element contains a pair of lists of edges representing two zig-zags that have a bad double crossing."
badDoubleCrossingZigZagQ::usage="Tells you whether the graph has 'bad double crossings'."
zigZagsAsPerfectMatchings::usage="Returns a list where each element consists of pairs of perfect matchings. The first perfect matching divided by the second one equals a given zig-zag. Since there may be multiple alternatives to reach the same zig-zag, each element in the returned list may contain multiple pairs."
matroidQ::usage="Tells you whether the inputted list of elements is a matroid or not."
matroidViolationCheck::usage="Returns a list of pairs of matroid elements that do not satisfy the exchange axiom."
pluckerRelations::usage="Returns a list of (generally not independent) Plucker relations. Each Plucker coordinate has the protected form minor[i,j,...]. It is necessary to act with ReleaseHold on the output of pluckerRelations to allow minor[i,j,...] etc. to take on predefined values."
independentPluckerRelations::usage="Returns a list with two elements: the first contains a list of all independent Plucker relations, and the second contains the solution to these equations."
(*We have to be able to bring the HoldForm[minor] out of the the package*)
minor::usage=""
makeOrderedPathMatrix::usage="This function returns the pathmatrix where, when possible, the external nodes have a cyclic planar ordering. IT SHOULD NOT BE LISTED IN THE LIST OF GLOBAL FUNCTIONS!"
makeAutomaticBoundariesAndCuts::usage="This function returns a list of boundaries, corresponding to each external node, and cuts between these boundaries. IT SHOULD NOT BE LISTED IN THE LIST OF GLOBAL FUNCTIONS!"
getGrassmannian::usage="This function returns the correspdoning element of the Grassmannian with all signs placed correctly to ensure manifest positivity of minors in planar diagrams, including signs associated to the rotation numnber of paths in the diagram. It only works when the graph can be embedded on genus zero (though it may have any number of boundaries)."
pluckerCoordinates::usage="Returns the external ordering and the Plucker coordinates of the on-shell diagram. It is posisble to specify whether this function should place in all signs according to the boundary measurement, or whether the path matrix is sufficient."

Begin["Private`"]


(*Basic functions that manipule and extract information from the Kasteleyn*)


joinupKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=joinupKasteleyn[topleft,topright,bottomleft,bottomright]=Join[Join[topleft,bottomleft],Join[topright,bottomright],2];

totFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
nf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
nf=Null;
];
nf
];

externalFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
externalnf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
externalnf=Null;
];
externalnf
];

internalFaces[topleft_,topright_,bottomleft_,bottomright_]:=totFaces[topleft,topright,bottomleft,bottomright]-externalFaces[topleft,topright,bottomleft,bottomright];

allFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
facelist=Null;
];
facelist
];

externalFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
facelist=Null;
];
facelist
];

internalFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Complement[allFaceLabels[topleft,topright,bottomleft,bottomright],externalFaceLabels[topleft,topright,bottomleft,bottomright]];


(*Functions useful for graph drawing and manipulation*)


getWeightedAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into a weightedadjaceny matrix*)
adjacencymatrix=Join[Join[ConstantArray[0,{Length[kasteleyn],Length[kasteleyn]}],Transpose[kasteleyn]],Join[kasteleyn,ConstantArray[0,{Dimensions[kasteleyn][[2]],Dimensions[kasteleyn][[2]]}]],2]/.{0->\[Infinity]};
adjacencymatrix
];

getAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into an adjaceny matrix*)
oneskasteleyn=kasteleyn/.Map[#->1&,Variables[kasteleyn]];
adjacencymatrix=Join[Join[ConstantArray[0,{Length[oneskasteleyn],Length[oneskasteleyn]}],Transpose[oneskasteleyn]],Join[oneskasteleyn,ConstantArray[0,{Dimensions[oneskasteleyn][[2]],Dimensions[oneskasteleyn][[2]]}]],2];
adjacencymatrix
];

viewGraph[topleft_,topright_,bottomleft_,bottomright_,showedges_:True]:=Module[{badedges,adjacencymat,kasteleyn,colors,graph,edgelist,vars,edgelabels,tempedgelabels,finalgraph,edgeweightname},
(*This needs to be a Module rather than Block, because otherwise my graph drawing at the end doesn't have access to the variable tempedgelabels!*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges==={},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We'll now make the bipartite coloring for the nodes of the graph*)
colors=MapThread[Rule,{Range[Total[Dimensions[kasteleyn]]],Join[ConstantArray[White,Length[kasteleyn]],ConstantArray[Black,Dimensions[kasteleyn][[2]]]]}];
(*We'll now get the edge list (by making a temporary graph), and use this edge list to print names on all the edges of the graph. The difficulty is largely due to giving differnt names to multiple edges going between two nodes (i.e. bubbles).*)
If[showedges==True,
graph=AdjacencyGraph[adjacencymat];
edgelist=EdgeList[graph];
vars=Variables[kasteleyn];
edgelabels=Map[Sort[(UndirectedEdge@@(Flatten[Position[kasteleyn,#]][[{1,2}]]+{0,Length[kasteleyn]}))]->#&,vars];
(*Now that we associated edges to their names, we'll make a temporary list from which we'll remove elements as they get printed onto the graph*)
tempedgelabels=edgelabels;
finalgraph=Graph[edgelist,EdgeShapeFunction->Function[{edgepositions,edgename},
edgeweightname=tempedgelabels[[Position[tempedgelabels,Sort[edgename]][[1,1]],2]];
tempedgelabels=Delete[tempedgelabels,Position[tempedgelabels,Sort[edgename]][[1,1]]];
{Text[Style[edgeweightname,Medium,Bold,Blue],Mean[edgepositions]],{Black,Line[edgepositions]}}],VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
,finalgraph=AdjacencyGraph[adjacencymat,VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
];
finalgraph
,Print["The Kasteleyn has multiple fields with the same name - can't draw the graph."];
finalgraph=Null;
];
finalgraph
];


(*Functions to check the Kasteleyn*)


duplicateEdges[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,doubleslist,kasteleynterms},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Make a list of edges that appear twice*)
doubleslist=Variables[kasteleyn][[Flatten[Position[Map[Length[Position[kasteleyn,#]]&,Variables[kasteleyn]],z_/;z>1]]]];
(*Also look for edges appearing with a minus, or with prefactors different from 1*)
kasteleynterms=Flatten[Map[MonomialList,DeleteCases[Flatten[kasteleyn],0]]];
Sort[Join[doubleslist,Variables[Complement[kasteleynterms,Variables[kasteleynterms]]]]]
];

edgesBFTformQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[z1_,z2_]/;IntegerQ[z1]&&IntegerQ[z2]]]==={}*)
Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[_Integer,_Integer]]]==={}
];

consistentKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,tocheck,rowsOK,columnsOK,consistencyviolation},
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*First check the rows of the Kasteleyn matrix corresponding to internal white nodes*)
tocheck=kasteleyn[[Range[Length[topleft]]]];
rowsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
(*Now check the columns of the Kasteleyn matrix corresponding to internal black nodes*)
tocheck=Transpose[kasteleyn[[All,Range[Dimensions[topleft][[2]]]]]];
columnsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
consistencyviolation={Flatten[Position[rowsOK,False]],Flatten[Position[columnsOK,False]]};
,consistencyviolation=Null;
];
consistencyviolation
];

checkKasteleynQ[topleft_,topright_,bottomleft_,bottomright_,BFTgraph_]:=Block[{return,badedges,indexmistakes},
return=True;
(*First check that the field hasn't been entered in twice*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges=!={},
(*if there are obvious mistakes, write them out*)
return=False;
Print["Check Kasteleyn: edges ",badedges," appear incorrectly."];
,If[BFTgraph,(*if there are no obvious mistakes, do more checks if we have a BFT graph*)
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],(*if the edges have the correct structure _[_,_] check for index mistakes*)
indexmistakes=consistentKasteleyn[topleft,topright,bottomleft,bottomright];
If[indexmistakes=!={{},{}},(*if we have index mistakes, point them out*)
return=False;
Print["There appears to be a mistake in the index structure in rows ",indexmistakes[[1]]," of the Kasteleyn."];
Print["There appears to be a mistake in the index structure in columns ",indexmistakes[[2]]," of the Kasteleyn."];
];
,return=False;(*we have a BFT with no doubles, but whose fields are not all in the right form*)
Print["Some edges have not been inputted in the correct form of _[_Integer,_Integer]"];
];
];
];
return
];


(*General functions for bipartita analysis*)


perfectMatchings[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=perfectMatchings[topleft,topright,bottomleft,bottomright]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{checkOK,externalrows,externalcolumns,rowandcolumnnumbers,rowsmergedonleftandright,newtonpolynomial,perfectmatchigns,zz},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph]
];
If[checkOK==True,
(*get all subsets of rows in bottomleft, and columns in topright*)
externalrows=Subsets[Range[Length[bottomleft]]];
externalcolumns=Subsets[Range[Length[Transpose[topright]]]];
(*Put these choices together, and only include those combinations that, when joined with topleft, leave a square matrix*)
rowandcolumnnumbers=Cases[Tuples[{externalrows,externalcolumns}],z_/;Equal@@(Map[Length,z]+Dimensions[topleft])];
(*For each case, merge topleft and the chosen rows of bottonleft. Also, merge the chosen columns of topright with the chosen columns and rows of bottomright.*)
rowsmergedonleftandright=Map[{Join[topleft,bottomleft[[#[[1]]]]],Join[topright[[All,#[[2]]]],bottomright[[#[[1]],#[[2]]]]]}&,rowandcolumnnumbers];
(*Now merge each case into a square matrix and compute its determinant. Then add up all the determinants.*)
newtonpolynomial=Total[Map[Det[Join[#[[1]],#[[2]],2]]&,rowsmergedonleftandright]];
(*Tidy up the signs, since perfect matchings are positive*)
perfectmatchigns=Sort[MonomialList[newtonpolynomial]/.{Times[-1,zz_]->Times[zz]}];
,perfectmatchigns=Null;
];
perfectmatchigns
];

getPmatrix[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*getPmatrix[topleft,topright,bottomleft,bottomright]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{varlist,plist,pmatrix},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
plist=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[plist=!=Null,
pmatrix=Table[MemberQ[Variables[plist[[jjj]]],varlist[[iii]]],{iii,Length[varlist]},{jjj,Length[plist]}]/.{True->1,False->0};
,pmatrix=Null;
];
pmatrix
];

survivingPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,edgelist_,checkneeded_:False,BFTgraph_:False]:=Block[{varlist,rowstokill,pmatrix,survivingcolums},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
rowstokill=Flatten[Position[varlist,Alternatives@@edgelist]];
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
survivingcolums=Complement[Range[Dimensions[pmatrix][[2]]],Map[#[[2]]&,Position[pmatrix[[rowstokill]],1]]];
,survivingcolums=Null;
];
survivingcolums
];

matroidPolytope[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*matroidPolytope[topleft,topright,bottomleft,bottomright]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{pmatrix,externaledges,externalrows,matroidpoly},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
(*Only select those rows corresponding to external edges in the graph*)
externaledges=Variables[Join[bottomleft,topright]];
externalrows=Flatten[Position[Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]],Alternatives@@externaledges]];
matroidpoly=pmatrix[[externalrows]];
,matroidpoly=Null;
];
matroidpoly
];

moduliSpaceBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1||gauging===2):=Block[{modulispace,matrixP,chargesFterm,gaugeCharge,edges,intfaces,gaugechargematrix,chargesDterm},
If[gauging==2,
modulispace=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
,If[gauging==1,
(*gauging 1 only works for graphs of BFT type, i.e. where the edges are labeled according to the faces they touch*)
matrixP=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,True];
If[matrixP=!=Null,
chargesFterm=NullSpace[matrixP];
gaugeCharge=Function[{edge,column},Block[{output=0},If[edge[[1]]==column,output=output+1;];If[edge[[2]]==column,output=output-1;];output]];
edges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
intfaces=internalFaceLabels[topleft,topright,bottomleft,bottomright];
gaugechargematrix=Table[gaugeCharge[edges[[iii]],intfaces[[jjj]]],{iii,Length[edges]},{jjj,Length[intfaces]}];
chargesDterm=Transpose[LinearSolve[matrixP,gaugechargematrix]];
modulispace=NullSpace[Join[chargesFterm,chargesDterm]];
,modulispace=Null;
];
];
];
modulispace
];

polytopeDim[mat_]:=Block[{dimension,newmat},
If[MemberQ[Transpose[mat],ConstantArray[0,Length[mat]]],
(*If the matrix has a column of zeros, the matrix rank gives you the dimension. Otherwise you need to shift the matrix so that a vertex is at the origin.*)
dimension=MatrixRank[mat];
,newmat=mat-mat[[All,1]];(*this operation automatically threads over all the columns of the matrix.*)
dimension=MatrixRank[newmat];
];
dimension
];

intoPolytope[mat_]:=Block[{columnsandmultiplicity,polytope,multiplicity},
columnsandmultiplicity=Tally[Transpose[mat]];
polytope=Transpose[Map[#[[1]]&,columnsandmultiplicity]];
multiplicity=Map[#[[2]]&,columnsandmultiplicity];
{polytope,multiplicity}
];

lowNumberLoopsPM[topleft_,topright_,bottomleft_,bottomright_]:=Block[{matroidpoly,multiplicitypolytope,perfmatchnumber},
matroidpoly=matroidPolytope[topleft,topright,bottomleft,bottomright];
multiplicitypolytope=intoPolytope[matroidpoly];
perfmatchnumber=Position[Transpose[matroidpoly],multiplicitypolytope[[1]][[All,Ordering[multiplicitypolytope[[2]]][[1]]]]][[1,1]];
perfmatchnumber
];

reducibilityBFTQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,reducibility},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]],reducibility=True;,reducibility=False;];
,reducibility=Null;
];
reducibility
];

reducibilityBFTedges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,problemlines,reducibilityedges},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
problemlines=Flatten[Position[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]]];
reducibilityedges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]][[problemlines]];
,reducibilityedges=Null;
];
reducibilityedges
];

consistentEdgeRemoval[topleft_,topright_,bottomleft_,bottomright_,edgelist_,checkneeded_:False,BFTgraph_:False]:=Block[{varlist,rowstokill,pmatrix,survivingcolums,reducedpmatrix,consistentedgelist},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
rowstokill=Flatten[Position[varlist,Alternatives@@edgelist]];
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
survivingcolums=Complement[Range[Dimensions[pmatrix][[2]]],Map[#[[2]]&,Position[pmatrix[[rowstokill]],1]]];
reducedpmatrix=pmatrix[[All,survivingcolums]];
consistentedgelist=varlist[[Flatten[Position[reducedpmatrix,ConstantArray[0,Dimensions[reducedpmatrix][[2]]]]]]];
,consistentedgelist=Null;
];
consistentedgelist
];

reductionGraphBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1||gauging===2):=Block[{edges,modulispace,numpointsmodulispace,comboremove,edgereductions,comboremovnextlevel,ii},
(*First check which edges can be removed without affeting the moduli space*)
edges=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edges=!=Null,
(*We will want to find those sets of edges which, when removed, do not change the numnber of points in the moduli space*)
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,False,BFTgraph];
numpointsmodulispace=Length[Tally[Transpose[modulispace]]];
comboremove=Subsets[edges,{1}];
edgereductions=comboremove;
(*Try and remove pairs of edges. In each case, we might need to remove additional edges for a consistent edge removal (this won't affect anything)*)
comboremovnextlevel=Subsets[edges,{2}];
(*In each case check whether the number of points in the moduli space is the same*)
comboremovnextlevel=Cases[comboremovnextlevel,zz_/;Length[Tally[Transpose[modulispace[[All,survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,zz,False,BFTgraph]]]]]]==numpointsmodulispace];
(*If it's possible to remove pairs of edges without changing the moduli space, it might be possible to remove 3 edges at a time, and so on*)
If[comboremovnextlevel=!={},
For[ii=3,ii<=Length[edges]+1,ii++,
edgereductions=Join[edgereductions,comboremovnextlevel];
comboremovnextlevel=Subsets[edges,{ii}];
comboremovnextlevel=Cases[comboremovnextlevel,zz_/;Length[Tally[Transpose[modulispace[[All,survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,zz,False,BFTgraph]]]]]]==numpointsmodulispace];
(*If no cases managed to preserve the number of points in the matroid polytope, stop here. comboremove contains the last viable choices for edge removals*)
If[comboremovnextlevel==={},
Break[];
];
];
];
edgereductions=Map[consistentEdgeRemoval[topleft,topright,bottomleft,bottomright,#,False,BFTgraph]&,edgereductions];
,edgereductions=Null;(*there was some problem with the Kasteleyn*)
];
edgereductions
];

edgeOrderings[edges_,currentedge_]:=Module[{orderings,ii},
(*Start with our current edge.*)
orderings={Cases[edges,currentedge]};
(*The next edge should have the structure _[currentedge[[2]],_]. There may however be multiple alternatives of this type, and not all of them are viable edge orderings that all match up. For for each alternative, try it out by adding this alternative onto {currentedge}. Ultimately we only want to keep those alternatives that match up.*)
For[ii=1,ii<Length[edges],ii++,
(*orderings contains a list of orderings. In each case, try and tag on another edge that makes sense. If there are none that make sense, this chain of edges wasn't a viable option for edge orderings, and this thread will get killed (because the MapThread function will take an empty list, and it will Map a Join function on each element of the empty list, which returns an empty list. "Sequence" then destroys it).*)
orderings=MapThread[Sequence@@Function[{input1,input2},Map[Join[input1,{#}]&,input2]][#1,#2]&,{orderings,Map[Cases[Complement[edges,#],_[Last[#][[2]],_]]&,orderings]}];
];
orderings=Map[RotateLeft,orderings];
orderings
];

nextStepBlackToWhite[topleftbottomleft_,currentedge_,currentposition_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[topleftbottomleft[[All,currentposition[[2]]]]],currentedge][[1]];
nextedge=nextedges[[1]];
nextedgepos=Position[topleftbottomleft,nextedge][[1]];
{nextedge,nextedgepos}
];

nextStepWhiteToBlack[toplefttopright_,currentedge_,currentposition_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[toplefttopright[[currentposition[[1]]]]],currentedge][[1]];
nextedge=nextedges[[1]];
nextedgepos=Position[toplefttopright,nextedge][[1]];
{nextedge,nextedgepos}
];

internalZigZagNumeratorDenominator[topleft_,topright_,bottomleft_,bottomright_,startingedge_,numeratorstart_:True]:=Block[{blacktowhitematrix,whitetoblackmatrix,kasteleyn,numeratoredges,denominatoredges,currentedge,currentposition},
blacktowhitematrix=Join[topleft,bottomleft];
whitetoblackmatrix=Join[topleft,topright,2];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
If[numeratorstart,
numeratoredges={startingedge};
denominatoredges={};
,numeratoredges={};
denominatoredges={startingedge};
];
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];

If[numeratorstart,
(*We will first need to go from a black vertex to a white vertex, then from black to white, and so on, until reaching the starting point*)
While[True,
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition];
If[currentedge===startingedge,
Break[];
];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
];
,(*We will first need to go from a white vertex to a black vertex, then from white to black, and so on, until reaching the starting point*)
While[True,
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition];
If[currentedge===startingedge,
Break[];
];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
];
];
{numeratoredges,denominatoredges}
];

allZigZagNumeratorsDenominators[topleft_,topright_,bottomleft_,bottomright_]:=Module[{kasteleyn,bottomleftvars,toprightvars,blacktowhitematrix,whitetoblackmatrix,zigZagFromExternalWhiteNode,zigZagFromExternalBlackNode,bottomleftzigzags,toprightzigzags,allnumeratoredges,alldenominatoredges,internalzigzagedges,internalzigzags,internalzigzag,allzigzags},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bottomleftvars=Variables[bottomleft];
toprightvars=Variables[topright];
blacktowhitematrix=Join[topleft,bottomleft];
whitetoblackmatrix=Join[topleft,topright,2];
(*We will begin by making a function that can give a zig-zag which starts from an external white node.*)
zigZagFromExternalWhiteNode=Function[{startingedge},Block[{currentedge,currentposition,denominatoredges,numeratoredges},
numeratoredges={startingedge};
denominatoredges={};
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];
While[True,
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
(*If we've reached another external node, we've finished the zig-zag*)
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
];
{numeratoredges,denominatoredges}]
];
zigZagFromExternalBlackNode=Function[{startingedge},Block[{currentedge,currentposition,denominatoredges,numeratoredges},
numeratoredges={};
denominatoredges={startingedge};
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];
While[True,
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition];
numeratoredges=Append[numeratoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition];
denominatoredges=Append[denominatoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
];
{numeratoredges,denominatoredges}]
];
(*Start from each of the external nodes and make the zig-zags that begin there.*)
bottomleftzigzags=Map[zigZagFromExternalWhiteNode[#]&,bottomleftvars];
toprightzigzags=Map[zigZagFromExternalBlackNode[#]&,toprightvars];
allnumeratoredges=Sort[Flatten[Map[#[[1]]&,Join[bottomleftzigzags,toprightzigzags]]]];
alldenominatoredges=Sort[Flatten[Map[#[[2]]&,Join[bottomleftzigzags,toprightzigzags]]]];
(*If there are any edges that do not appear in any of the numerators, we must have a zig-zag path which is purely internal*)
(*Start from each of the edges that are missing a zig-zag, and create the internal zig-zags that run over this edge*)
internalzigzagedges=Complement[Variables[kasteleyn],allnumeratoredges];
internalzigzags={};
While[internalzigzagedges=!={},
internalzigzag=internalZigZagNumeratorDenominator[topleft,topright,bottomleft,bottomright,internalzigzagedges[[1]]];
internalzigzags=Append[internalzigzags,internalzigzag];
allnumeratoredges=Join[allnumeratoredges,internalzigzag[[1]]];
alldenominatoredges=Join[alldenominatoredges,internalzigzag[[2]]];
internalzigzagedges=Complement[Variables[kasteleyn],allnumeratoredges];
];
(*There shouldn't be, but just in case also look at edge in the denominator in case there's some zig-zag we're missing*)
internalzigzagedges=Complement[Variables[kasteleyn],alldenominatoredges];
While[internalzigzagedges=!={},
internalzigzag=internalZigZagNumeratorDenominator[topleft,topright,bottomleft,bottomright,internalzigzagedges[[1]],False];
internalzigzags=Append[internalzigzags,internalzigzag];
allnumeratoredges=Join[allnumeratoredges,internalzigzag[[1]]];
alldenominatoredges=Join[alldenominatoredges,internalzigzag[[2]]];
internalzigzagedges=Complement[Variables[kasteleyn],alldenominatoredges];
];
(*Now all edges have appeared in the numerator of some zig-zag and the denominator of some (possibly the same) zig-zag*)
allzigzags=Join[bottomleftzigzags,toprightzigzags,internalzigzags];
(*If there are any edges that do not appear in the actual expressions for the zig-zags, it means we have a self-intersecting zig-zag*)
allzigzags
];

makeZigZags[topleft_,topright_,bottomleft_,bottomright_,invertedrule_:False]:=Block[{graphOK,allzigzags,zigzagexpressions},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
zigzagexpressions=Map[(Times@@#[[1]])/(Times@@#[[2]])&,allzigzags];
(*If we want to turn right at white nodes and left at black nodes, all the zig-zags are inverted*)
If[invertedrule,
zigzagexpressions=Map[1/#&,zigzagexpressions];
];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
zigzagexpressions=Null;
];
zigzagexpressions
];

selfIntersectingZigZagsQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{graphOK,allzigzags,selfintersectingzigzags,selfintersections},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
(*If an edge is both in the numerator and the denominator, we have a self-intersection*)
selfintersectingzigzags=Cases[allzigzags,zz_/;Length[Intersection[zz[[1]],zz[[2]]]]>0];
If[Length[selfintersectingzigzags]=!=0,
selfintersections=True;
,selfintersections=False;
];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
selfintersections=Null;
];
selfintersections
];

badDoubleCrossingZigZagPairs[topleft_,topright_,bottomleft_,bottomright_]:=Module[{graphOK,edgeChronology,allzigzags,firstedges,internalzigzags,allzigzagpairs,doubleCrossingQ,doublecrossings},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
(*We begin by making all edges in the zig-zags appear in chronological order*)
edgeChronology=Function[{edges,firstedge},
Block[{orderings,ii},
orderings={DeleteDuplicates[Cases[edges,firstedge]]};
For[ii=1,ii<Length[edges],ii++,
orderings=orderings=MapThread[Sequence@@Function[{input1,input2},Map[Join[input1,{#}]&,input2]][#1,#2]&,{orderings,Map[Cases[Variables[Plus@@edges-Plus@@#],_[Last[#][[2]],_]]&,orderings]}];
];
orderings]
];
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
(*We will make a list containing the first edge of each zig-zag, where for internal zig-zags there is no first edge so we will take the first edge in the numerator*)
firstedges=MapThread[Join[#1,#2,#3][[1]]&,{Map[#[[1]]&,Map[Intersection[#,Variables[bottomleft]]&,allzigzags,{2}]],Map[#[[2]]&,Map[Intersection[#,Variables[topright]]&,allzigzags,{2}]],Map[#[[1]]&,Map[Intersection[#,Variables[topleft]]&,allzigzags,{2}]]}];
allzigzags=Map[Join@@#&,allzigzags];
allzigzags=MapThread[edgeChronology[#1,#2][[1]]&,{allzigzags,firstedges}];
(*Now we have the chronological list of edes in each zig-zag. We need to now look at the pairwaise intersections between them to determine whether we have "bad double crossings"*)
(*Since internal zig-zags are cyclic, we will write out two cycles of them, so that multiple intersections can be seen to occur chronologically correctly*)
internalzigzags=Cases[allzigzags,zz_/;Intersection[zz,Variables[Join[bottomleft,topright]]]==={}];
allzigzags=allzigzags/.Map[#->Join[#,#]&,internalzigzags];
allzigzagpairs=Subsets[allzigzags,{2}];
doubleCrossingQ=Function[{zigzag1,zigzag2},
Block[{intersectionvars,zig1intersectionpairs,zig2intersections,badcrossing},
intersectionvars=Alternatives@@Intersection[zigzag1,zigzag2];
(*Look at all pairs of variables in zigzag1 and see whether they appear in the same order*)
zig1intersectionpairs=Subsets[Cases[zigzag1,intersectionvars],{2}];
zig2intersections=Cases[zigzag2,intersectionvars];
badcrossing=Or@@Map[Cases[zig2intersections[[Range[Position[zig2intersections,#[[1]]][[1,1]],Length[zig2intersections]]]],#[[2]]]=!={}&,zig1intersectionpairs];
badcrossing]
];
doublecrossings=Cases[allzigzagpairs,zz_/;doubleCrossingQ@@zz];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
doublecrossings=Null;
];
doublecrossings
];

badDoubleCrossingZigZagQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{baddoublecrossings,return},
baddoublecrossings=badDoubleCrossingZigZagPairs[topleft,topright,bottomleft,bottomright];
If[baddoublecrossings=!=Null,
return=baddoublecrossings=!={};
,return=Null;];
return
];

zigZagsAsPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,invertedrule_:False]:=Block[{zigzags,perfmatchings,perfmatchzigzags,ii,jj,perfmatchratio,positions,tobereplacedwith,replacementrule},
zigzags=makeZigZags[topleft,topright,bottomleft,bottomright,invertedrule];
If[zigzags=!=Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright,False,True];
perfmatchzigzags=Table[{},{iii,Length[zigzags]}];
For[ii=1,ii<=Length[perfmatchings],ii++,
For[jj=1,jj<=Length[perfmatchings],jj++,
perfmatchratio=perfmatchings[[ii]]/perfmatchings[[jj]];
positions=Flatten[Position[Map[#===perfmatchratio&,zigzags],True]];
tobereplacedwith=Map[Append[#,{perfmatchings[[ii]],perfmatchings[[jj]]}]&,perfmatchzigzags[[positions]]];
replacementrule=MapThread[Rule,{positions,tobereplacedwith}];
perfmatchzigzags=ReplacePart[perfmatchzigzags,replacementrule];
];
];
,perfmatchzigzags=Null;
];
perfmatchzigzags
];



(*Functions useful for scattering amplitudes*)


planarityQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymat,graph,planar,externals,extnum,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
(*If the graph can be embedded on genus zero, try and see if we can do so with only one boundary*)
planar=False;(*assume the graph is non-planar until proven otherwise*)
If[PlanarGraphQ[graph],
externals=Flatten[Position[Map[Total,adjacencymat],1]];(*These are the row-numbers corresponding to external nodes*)
extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
permutations=Map[Append[#[[1]],extnum]&,Gather[Permutations[Range[extnum-1]],#1==Reverse[#2]&]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],
planar=True;
Break[];
];
];
];
planar
];

externalOrderingDefault[topright_,bottomleft_]:=Block[{ordering},
ordering=Flatten[DeleteCases[Join[bottomleft,Transpose[topright]],0,{2}]];
ordering=MapThread[Rule,{ordering,Range[Length[ordering]]}];
ordering
];

findSources[topright_,bottomleft_,referenceperfmatch_]:=Block[{referencevars,sourceedges},
referencevars=Variables[referenceperfmatch];
(*Sources are those variables in the bottomleft that are not in referenceperfmatch, and those in topright which are*)
sourceedges=Union[Complement[DeleteCases[Flatten[bottomleft],0],referencevars],Intersection[DeleteCases[Flatten[topright],0],referencevars]];
sourceedges
];

findSinks[topright_,bottomleft_,referenceperfmatch_]:=Block[{perfmatchvars,sinkedges},
perfmatchvars=Variables[referenceperfmatch];
(*Sinks are those variables in the bottomleft that are in referenceperfmatch, and those in topright which are not*)
sinkedges=Union[Complement[DeleteCases[Flatten[topright],0],perfmatchvars],Intersection[DeleteCases[Flatten[bottomleft],0],perfmatchvars]];
sinkedges
];

externalEdgesNodeNumbers[topleft_,topright_,bottomleft_,bottomright_,externaledgelist_]:=Union[Map[#[[1]]&,Position[bottomleft,Alternatives@@externaledgelist]+Length[topleft]],Map[#[[2]]&,Position[topright,Alternatives@@externaledgelist]+Total[Dimensions[topleft]]+Length[bottomleft]]];

connectivityMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=connectivityMatrix[topleft,topright,bottomleft,bottomright,referencematching]=connectivityMatrix[topleft,topright,bottomleft,bottomright]=Block[{referenceperfmatch,kasteleyn,perfmatchvars,kastnopm,kastinvertedpm,bigmatrix,connectivitymat},
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
perfmatchvars=Variables[referenceperfmatch];
(*We need to first form a large matrix based on the Kasteleyn, and then take its inverse*)
kastnopm=-(kasteleyn/.Map[#->0&,perfmatchvars]);
kastinvertedpm=-Transpose[kasteleyn/.Join[Map[#->1/#&,perfmatchvars],Map[#->0&,Complement[Variables[kasteleyn],perfmatchvars]]]];
bigmatrix=Join[Join[IdentityMatrix[Length[kasteleyn]],kastinvertedpm],Join[kastnopm,IdentityMatrix[Dimensions[kasteleyn][[2]]]],2];
connectivitymat=Inverse[bigmatrix];
connectivitymat
];

pathMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=Block[{referenceperfmatch,bigpathmatrix,externalrows,externalcolumns,finalpathmatrix},
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
bigpathmatrix=connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
(*bigpathmatrix contains the connectivity between ALL pairs of nodes. We need to select those entries corresponding to sources goign to external nodes.*)
externalrows=externalEdgesNodeNumbers[topleft,topright,bottomleft,bottomright,findSources[topright,bottomleft,referenceperfmatch]];
externalcolumns=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];
finalpathmatrix=Expand[Simplify[bigpathmatrix[[externalrows,externalcolumns]]]];
(*The determinant of bigpathmatrix gives the loop factor in the paths between external nodes.*)
finalpathmatrix
];

minorsAsPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright]=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright,referencematching]=Block[{referenceperfmatch,pathmat,minors,loopdenominator,truemapminortoperfmatch},
(*If we haven't selected a specific perfect matching, choose one with lowest possible multiplicity*)
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
minors=Minors[pathmat,Length[pathmat]][[1]];
loopdenominator=Expand[referenceperfmatch/Expand[Simplify[Det[connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]]]]];
truemapminortoperfmatch=Expand[Simplify[minors loopdenominator]];
truemapminortoperfmatch
];

dimensionGrassmannian[topleft_,topright_,bottomleft_,bottomright_]:=dimensionGrassmannian[topleft,topright,bottomleft,bottomright]=Block[{minorexpressions,minorvars,tangentspacedim},
minorexpressions=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright];
minorvars=Variables[minorexpressions];
(*When computing the tangent space we need to subtract 1, because Plucker coordinates are projective variables*)
tangentspacedim=MatrixRank[Table[D[minorexpressions[[iii]],minorvars[[jjj]]],{iii,Length[minorexpressions]},{jjj,Length[minorvars]}]]-1;
tangentspacedim
];

reducibilityQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{edgesnaivereducibility,reducibility,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibility=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibility=False;
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibility=True;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
If[polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright]]>dimgrassmannian,
(*if the dimension of the Grassmannian is less than that from a naive counting of edges and perfect matchings, it is necessarily possible to remove edges without affecting the Grassmannian*)
reducibility=True;
,reducibility=False;
(*assume the graph is not reducible until you find an edge which, when removed, does not reduce the dimension*)
For[ii=1,ii<=Length[edgesnaivereducibility],ii++,
dimafteredgeremoval=dimensionGrassmannian[topleft/.{edgesnaivereducibility[[ii]]->0},topright/.{edgesnaivereducibility[[ii]]->0},bottomleft/.{edgesnaivereducibility[[ii]]->0},bottomright];
If[dimafteredgeremoval==dimgrassmannian,
(*we have found an edge which may be removed without decreasing the dimension of the Grassmannian!*)
reducibility=True;
Break[]
];
];
];
];
];
];
reducibility
];

reducibilityEdges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{edgesnaivereducibility,reducibilityedgelist,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibilityedgelist=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibilityedgelist={};
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibilityedgelist=edgesnaivereducibility;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
(*Just select those edgs which, when removed, do not decrease the dimension of the Grassmannian*)
reducibilityedgelist=Cases[edgesnaivereducibility,zz_/;dimensionGrassmannian[topleft/.{zz->0},topright/.{zz->0},bottomleft/.{zz->0},bottomright]==dimgrassmannian];
];
];
];
reducibilityedgelist
];

reductionGraph[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]:=Block[{naivereductionedges,reductionedges,dimgrassmannian},
naivereductionedges=reductionGraphBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[naivereductionedges=!=Null,
If[naivereductionedges==={},
reductionedges={};
,(*If the graph is planar or is a BFT, the BFT definition of reductions is valid*)
If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
reductionedges=naivereductionedges;
,(*we have a non-planar scattering graph, and must be more careful*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
(*We only want those sets of edges which, when removed, do not reduce the dimension of the Grassmannian*)
reductionedges=Cases[naivereductionedges,zz_/;dimensionGrassmannian[topleft/.Map[#->0&,zz],topright/.Map[#->0&,zz],bottomleft/.Map[#->0&,zz],bottomright]==dimgrassmannian];
];
];
,reductionedges=Null;
];
reductionedges
];

nonPluckerPolesQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False]:=Block[{fullreducibility,nonstandardpoles},
(*Can only tell if the graph is reduced*)
fullreducibility=reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded];
If[fullreducibility=!=Null,
If[reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded]==False,
(*If the graph is reduced but the naive reducibility tells you that it's possible to remove edges without killing any Plucker coordinates, it means that some poles are nonstandard poles, i.e. that they aren't simply products of Plucker coordinates*)
nonstandardpoles=reducibilityBFTQ[topleft,topright,bottomleft,bottomright,checkneeded];
,Print["Need to start with a reduced graph."];
nonstandardpoles=Null;
];
,nonstandardpoles=Null;
];
nonstandardpoles
];

removableEdges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]:=Block[{startingpointbad,removables,varlist,varstotryout,quickReducibility,fullpmatrix,fullmodulispace,survivingperfmatchings,survivingrows,reducibilities},
startingpointbad=False;
If[checkneeded,
startingpointbad=reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
];
If[startingpointbad=!=Null,
If[startingpointbad,
Print["The starting graph is reducible. Reduce it first, using reductionGraph."];
removables=Null;
,(*We need to try to remove in turn each of the edges of the graph, and check whether the resulting graph is reducible*)
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
varstotryout=Map[consistentEdgeRemoval[topleft,topright,bottomleft,bottomright,{#},False,BFTgraph]&,varlist];
(*If we have a BFT graph, or a planar scattering graph, or a nonplanar scattering graph with no non-standard poles, we may use the moduli space / matroid polytope to determine reducibility.*)
If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright]||nonPluckerPolesQ[topleft,topright,bottomleft,bottomright]==False,
(*Create a function that can give the reducibility of a given P-matrix with its corresponding moduli space / matroid polytope*)
quickReducibility=Function[{pmatrix,modulispace},
Block[{pmatrixtranspose,modulitranspose,pmatrixshort,reducib},
pmatrixtranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
pmatrixshort=Transpose[Map[Times@@pmatrixtranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[pmatrixshort,ConstantArray[0,Dimensions[pmatrixshort][[2]]]],reducib=True;,reducib=False;];
reducib]];
(*Now make the P-matrix and the moduli space / matroid polytope for the full graph*)
fullpmatrix=getPmatrix[topleft,topright,bottomleft,bottomright];
fullmodulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,False,BFTgraph];
(*In each of the edge-removals to try out, see which perfect matchings survive*)
survivingperfmatchings=Map[survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,#,False,BFTgraph]&,varstotryout];
(*Also note which rows in P survive (all rows except for those corresponding to the edges we're trying to kill)*)
survivingrows=Map[Complement[Range[Length[varlist]],Flatten[Position[varlist,Alternatives@@#]]]&,varstotryout];
(*In each edge-removal case, now use quickReducibility to see whether the resulting graph is reducible or not*)
reducibilities=MapThread[quickReducibility[fullpmatrix[[#1,#2]],fullmodulispace[[All,#2]]]&,{survivingrows,survivingperfmatchings}];
(*Only keep those cases for which the resulting graph is not reducible*)
removables=varstotryout[[Flatten[Position[reducibilities,False]]]];
,(*we have a non-planar graph with nonstanard poles, so we need to check things carefully.*)
(*Only keep those cases for which the resulting graph is not reducible*)
removables=Cases[varstotryout,zz_/;reducibilityQ[topleft/.Map[#->0&,zz],topright/.Map[#->0&,zz],bottomleft/.Map[#->0&,zz],bottomright,False,BFTgraph,gauging]==False];
];
];
,removables=Null;
];
removables
];

matroidQ[inputmatroid_,checkneeded_:True]:=Block[{matroidcheck,matroidOK},
matroidcheck=matroidViolationCheck[inputmatroid,checkneeded];
If[matroidcheck=!=Null,
matroidOK=matroidViolationCheck[inputmatroid,checkneeded]==={};
,matroidOK=Null;
];
matroidOK
];

matroidViolationCheck[inputmatroid_,checkneeded_:True]:=Module[{inputOK,matroid,matroidelementpairs,checkMatroidPair,badmatroidelementpairs},
inputOK=True;
If[checkneeded,
inputOK=Head[inputmatroid]===List&&And@@Map[Head[#]===List&,inputmatroid]&&And@@Flatten[Map[Head[#]===Integer&,inputmatroid,{2}]];
];
If[inputOK,
matroid=Map[Sort,inputmatroid];
matroidelementpairs=Subsets[matroid,{2}];
checkMatroidPair=Function[{matroidelementpair},
Block[{matroidpairOK,ii,jj,newelement},
matroidpairOK={};
For[ii=1,ii<=Length[matroidelementpair[[1]]],ii++,
newelement=Delete[matroidelementpair[[1]],ii];
For[jj=1,jj<=Length[matroidelementpair[[2]]],jj++,
(*If there is any one that works, this matroid pair is OK.*)
If[MemberQ[matroid,Sort[Append[newelement,matroidelementpair[[2,jj]]]]],
matroidpairOK=Append[matroidpairOK,True];
Break[]
];
If[jj==Length[matroidelementpair[[2]]],matroidpairOK=Append[matroidpairOK,False];];
];
];
For[ii=1,ii<=Length[matroidelementpair[[2]]],ii++,
newelement=Delete[matroidelementpair[[2]],ii];
For[jj=1,jj<=Length[matroidelementpair[[1]]],jj++,
(*If there is any one that works, this matroid pair is OK.*)
If[MemberQ[matroid,Sort[Append[newelement,matroidelementpair[[1,jj]]]]],
matroidpairOK=Append[matroidpairOK,True];
Break[]
];
If[jj==Length[matroidelementpair[[1]]],matroidpairOK=Append[matroidpairOK,False];];
];
];
matroidpairOK=And@@matroidpairOK;
matroidpairOK]
];
badmatroidelementpairs=Cases[matroidelementpairs,zz_/;checkMatroidPair[zz]==False];
,badmatroidelementpairs=Null;
Print["The input must be of the form {{_Integer,_Integer,...},...}"];
];
badmatroidelementpairs
];

pluckerRelations[k_Integer,n_Integer]:=pluckerRelations[k,n]=Block[{indexlist1,indexlist2,relations,conditions,i,j,oppositerelations,todelete,ii},
indexlist1=Subsets[Range[n],{k-1}];
indexlist2=Subsets[Range[n],{k+1}];
relations={};
conditions=Map[HoldForm[minor][Sequence@@#]->0&,indexlist1];
For[i=1,i<Length[indexlist1]+1,i++,
For[j=1,j<Length[indexlist2]+1,j++,
relations=Join[relations,{Sum[(-1)^(dum-1) (-1)^(PermutationOrder[Ordering[DeleteDuplicates[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]]-1) HoldForm[minor][Sequence@@Union[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]HoldForm[minor][Sequence@@Complement[indexlist2[[j]],{indexlist2[[j,dum]]}]],{dum,k+1}]==0}/.conditions];
];
];
relations=DeleteDuplicates[DeleteCases[relations,True]];
(*Remove the ones that are duplicate up to a minus sign*)
oppositerelations=Map[-#[[1]]==0&,relations];
todelete={};
For[ii=1,ii<=Length[relations],ii++,
If[FreeQ[todelete,ii],
todelete=Join[todelete,Flatten[Position[oppositerelations,relations[[ii]]]]];
];
];
relations=relations[[Complement[Range[Length[relations]],todelete]]](*/.{minor\[Rule]HoldForm[minor]}*);
relations
];

independentPluckerRelations[k_Integer,n_Integer]:=Block[{pluckerrel,numindeppluckerrelations,solutions,independentrelations,newsolution,ii},
pluckerrel=pluckerRelations[k,n];
(*The number of independent plucker relations*)
numindeppluckerrelations=Binomial[n,k]-1-k(n-k);
solutions={};
(*If we have any plukcer relations, start solving them*)
If[pluckerrel=!={},
independentrelations=pluckerrel[[{1}]];(*this variable will contain all independent relations*)
newsolution=DeleteCases[Solve[And@@independentrelations],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];(*this variable will contain all independent solutions*)
(*Go through the remianing plucker relations. If the next Plucker relations is not triviliazied by the solutions we already found to the previous relations, add it to the list of independent relations, and solve it.*)
For[ii=2,ii<=Length[pluckerrel],ii++,
If[Simplify[pluckerrel[[ii]]//.solutions]=!=True,
independentrelations=Append[independentrelations,pluckerrel[[ii]]];
newsolution=DeleteCases[Solve[And@@Simplify[independentrelations//.solutions]],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];
(*If we have found as many solutions as there are independent relations in total, stop here, since the remainigs Plucker relations cannot be independent*)
If[Length[solutions]==numindeppluckerrelations,
Break[];
];
];
];
(*Tidy up the solutions so that they all depend on the same set of variables*)
solutions=MapThread[Rule,{Map[#[[1]]&,solutions],Simplify[Map[#[[2]]&,solutions]//.solutions]}];
,(*if there are no Plucker relations, return empty sets*)
independentrelations={};
];
{independentrelations,solutions}
];

makeOrderedPathMatrix[adjacencymatrix_,pathmat_,externalordering_,topleft_,topright_,bottomleft_,bottomright_]:=Block[{adjacencymat,planar,externals,extnum,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph,ordering,rowordering,orderedpathmat},
adjacencymat=adjacencymatrix;
planar=False;
If[externalordering===Null,
(*If we haven't specified an external ordering, make a cyclic ordering when planar. If not planar, pick a default ordering based on the Kasteleyn*)
(*Let's see if we can find a planar cyclic ordering*)
externals=Flatten[Position[Map[Total,adjacencymat],1]];(*These are the row-numbers corresponding to external nodes*)
extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
permutations=Map[Append[#[[1]],extnum]&,Gather[Permutations[Range[extnum-1]],#1==Reverse[#2]&]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],(*we found a cyclic planar ordering!*)
planar=True;
ordering=Ordering[permutations[[ii]]];
rowordering=Ordering[Flatten[Map[Position[ordering,#]&,Flatten[Map[Position[Transpose[pathmat],#]&,IdentityMatrix[Length[pathmat]]]]]]];
orderedpathmat=pathmat[[rowordering,ordering]];
Break[];
];
];
If[planar==False,(*if the graph is non-planar, pick the default ordering*)
orderedpathmat=pathmat;
];
,(*if we specified an ordering, use that instead. Here we don't care whether the graph is planar or not, since the user is forced to specify all the boundaries and cuts etc.*)
(*externalOrderingDefault is the same as that chosen by pathMatrix*)
ordering=externalordering/.externalOrderingDefault[topright,bottomleft];
rowordering=Ordering[Flatten[Map[Position[ordering,#]&,Flatten[Map[Position[Transpose[pathmat],#]&,IdentityMatrix[Length[pathmat]]]]]]];
orderedpathmat=pathmat[[rowordering,ordering]];
];
{orderedpathmat,planar}
];

makeAutomaticBoundariesAndCuts[graph_,topleft_,topright_,bottomleft_,bottomright_]:=Module[{planargraph,verticespos,edgepos,boundaries,externalnodenumbers,nodenumberstoedges,verticestocoords,externalvertices,spiralInList,cutcoordinates,cutcoordinatesandnodes,edgesCrossQ,crossedEdges,cutsedgecrossings,extraCutEdges,extracrossededges,kasteleyn,bigkasteleyn,nameUndirectedEdges,edgenamerule,boundarypaircuts},
If[PlanarGraphQ[graph],
(*We shall begin by drawing out the graph such that no edges cross. In so doing we'll be able to extract the vertex coordinates and edge positions of this embedding*)
planargraph=Graph[graph,GraphLayout->"PlanarEmbedding"];
verticespos=MapThread[{#1,#2}&,{Range[Length[GraphEmbedding[planargraph]]],GraphEmbedding[planargraph]}];
edgepos=Map[{{verticespos[[#[[1]],2]],verticespos[[#[[2]],2]]},#}&,EdgeList[planargraph]];
edgepos=DeleteDuplicates[edgepos];(*in case there are bubbles*)
(*Now we have the vertices and edges for an embedding with no edge crossings*)
(*Each external vertex will be seen as having its own tiny boundary attached to it*)
boundaries=Transpose[{Flatten[DeleteCases[Join[bottomleft,Transpose[topright]],0,{2}]]}];
(*Now we'll construct the cuts: they will run directly between the external vertices, since the boundaries are so tiny*)
externalnodenumbers=Join[Range[Length[bottomleft]]+Length[topleft],Range[Dimensions[topright][[2]]]+Total[Dimensions[topleft]]+Length[bottomleft]];
verticestocoords=Map[Rule@@#&,verticespos];
externalvertices=externalnodenumbers/.verticestocoords;
(*Now we'll need to make a sequence of boundaries connected by cuts. We'll start with the external node with the highest y-coordinate, and proceed along external nodes as we spiral in to the middle. This ensures that the cuts never cross each other*)
(*Before we start we'll make a rule that translates node numbers into edge labels. This will be useful to us at the very end*)
nodenumberstoedges=MapThread[Rule,{externalnodenumbers,Flatten[boundaries]}];
(*This function takes a list of vertices and orders them according to the spiralling-in order*)
spiralInList=Function[{vertexlist},
Block[{remainingvertices,nextnode,finalvertexlist,polardistances},
remainingvertices=vertexlist;
(*The first node is the one with the largest y-coordinate*)
nextnode=Cases[remainingvertices,{_,Max[Map[#[[2]]&,remainingvertices]]}][[1]];
finalvertexlist={nextnode};
remainingvertices=DeleteCases[remainingvertices,nextnode];
While[remainingvertices=!={},
polardistances=Map[{#[[1]],Mod[#[[2]],2Pi]}&,Map[ToPolarCoordinates[#-nextnode]&,remainingvertices]];
(*The next node is the first one reached going radially and clockwise from the current node*)
nextnode=Cases[polardistances,{_,Max[Map[#[[2]]&,polardistances]]}];
(*If there are multiple ones with the same angle, pick the nearest one*)
nextnode=Cases[nextnode,{Min[Map[#[[1]]&,nextnode]],_}][[1]];
nextnode=remainingvertices[[Position[polardistances,nextnode][[1,1]]]];
finalvertexlist=Append[finalvertexlist,nextnode];
remainingvertices=DeleteCases[remainingvertices,nextnode];
];
finalvertexlist]
];
(*Now we'll order our external vertices and our boundaries in this new order*)
externalvertices=spiralInList[externalvertices];
boundaries=Map[{#}&,externalvertices/.Map[#[[2]]->#[[1]]&,verticestocoords]]/.nodenumberstoedges;
(*We may now form the cuts: they are (n-1) sequential pairs of externalvertices*)
cutcoordinates=Table[{externalvertices[[iii]],externalvertices[[iii+1]]},{iii,Length[externalvertices]-1}];
(*For convenience we'll also append to each of these pairs the two node numbers that they represent*)
cutcoordinatesandnodes=MapThread[{#1,#2}&,{cutcoordinates,Map[Alternatives@@#&,cutcoordinates/.Map[#[[2]]->#[[1]]&,verticestocoords]]}];
(*Now we need to see which edges are crossed by each cut (remember that in each cut we don't want to consider cutting edges that pass through the two external nodes)*)
(*This function tells you whether two generic segments cross*)
edgesCrossQ=Function[{cutcoords,edgecoords},
Block[{matrixtoinvert,crossdistance,newcutcoords,crossq},
matrixtoinvert={{cutcoords[[1,1]]-cutcoords[[2,1]],edgecoords[[2,1]]-edgecoords[[1,1]]},{cutcoords[[1,2]]-cutcoords[[2,2]],edgecoords[[2,2]]-edgecoords[[1,2]]}};
If[Det[matrixtoinvert]=!=0.,(*if the matrix is invertible*)
crossdistance=Inverse[matrixtoinvert].{cutcoords[[1,1]]-edgecoords[[1,1]],cutcoords[[1,2]]-edgecoords[[1,2]]};
If[crossdistance[[2]]==1.||crossdistance[[2]]==0.,(*we are touching the endpoint of an edge*)
(*In this case we should slightly shift the cut downwards and so that it doesn't go right through the node*)
newcutcoords=Map[#-{0,0.05}&,cutcoords];
matrixtoinvert={{newcutcoords[[1,1]]-newcutcoords[[2,1]],edgecoords[[2,1]]-edgecoords[[1,1]]},{newcutcoords[[1,2]]-newcutcoords[[2,2]],edgecoords[[2,2]]-edgecoords[[1,2]]}};
If[Det[matrixtoinvert]=!=0.,
crossdistance=Inverse[matrixtoinvert].{newcutcoords[[1,1]]-edgecoords[[1,1]],newcutcoords[[1,2]]-edgecoords[[1,2]]};
,crossq=False;
];
];
crossq=And@@Map[(#>=0)&&(#<=1)&,crossdistance];
,(*the edges are parallel, and cannot cross*)
crossq=False;
];
crossq]
];
(*This function takes a cut and tells you which UndirectedEdges in the graph it crosses*)
crossedEdges=Function[{cutinfo},
Map[#[[2]]&,DeleteCases[Cases[edgepos,zz_/;edgesCrossQ[cutinfo[[1]],zz[[1]]]],{___,UndirectedEdge[_,cutinfo[[2]]]}|{___,UndirectedEdge[cutinfo[[2]],_]}]]
];
(*Now we're able to determine which edges are crossed by each cut*)
cutsedgecrossings=Map[crossedEdges,cutcoordinatesandnodes];
(*In order to maintain the ordering of nodes we determined with our cuts, sometimes we need an external edge to be crossed an additional time by one of the two cuts in order to keep its position in the order of external nodes*)
(*This function takes a pair of cuts and returns a list containing the additional edges that get crossed. We should assume that it is the first of the pair of cuts that crosses the edge*)
extraCutEdges=Function[{pairofcutscoordinates},
Block[{pairofcuts,externaledgename,externaledge,cutangles,edgeangle,rotatedcutangles,rotatededgeangle,return},
pairofcuts=pairofcutscoordinates;
externaledgename=Cases[edgepos,{{___,pairofcuts[[1,2]],___},___}][[1,2]];
externaledge=Cases[edgepos,{{___,pairofcuts[[1,2]],___},___}][[1,1]];
externaledge=DeleteCases[Map[#-pairofcuts[[1,2]]&,externaledge],{0.,0.}];
pairofcuts=DeleteCases[Sequence@@@Map[#-pairofcuts[[1,2]]&,pairofcuts,{2}],{0.,0.}];
cutangles=Map[Mod[#[[2]],2Pi]&,Map[ToPolarCoordinates,pairofcuts]];
edgeangle=Map[Mod[#[[2]],2Pi]&,Map[ToPolarCoordinates,externaledge]];
rotatedcutangles=Mod[cutangles-cutangles[[1]],2Pi];
rotatededgeangle=Mod[edgeangle-cutangles[[1]],2Pi];
If[rotatededgeangle[[1]]<rotatedcutangles[[2]],
return={externaledgename};
,return={};
];
return]
];
(*For each pair of cuts, we now get the additional edges that get crossed*)
extracrossededges=Map[extraCutEdges,Table[{cutcoordinates[[iii]],cutcoordinates[[iii+1]]},{iii,Length[cutcoordinates]-1}]];
(*These are added to cutsedgecrossings. Since the last cut never crosses an edge, add an empty list*)
extracrossededges=Append[extracrossededges,{}];
cutsedgecrossings=Map[DeleteDuplicates,MapThread[Join,{cutsedgecrossings,extracrossededges}]];
(*We need to translate this into actual edge variable names*)
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bigkasteleyn=Join[kasteleyn,Transpose[kasteleyn]];
nameUndirectedEdges=Function[{undirectededge},
undirectededge->Sequence@@Intersection@@Map[Variables[bigkasteleyn[[#]]]&,List@@undirectededge]
];
edgenamerule=Map[nameUndirectedEdges,DeleteDuplicates[EdgeList[graph]]];
cutsedgecrossings=Map[#->-#&,cutsedgecrossings/.edgenamerule,{2}];
boundarypaircuts=MapThread[Rule,{Table[{boundaries[[iii]],boundaries[[iii+1]]},{iii,Length[boundaries]-1}],cutsedgecrossings}];
,Print["It must be possible to embed the graph on genus zero without any edges crossing."];
boundaries=Null;
boundarypaircuts=Null;
];
{boundaries,boundarypaircuts}
];

getGrassmannian[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,externalordering_:Null,boundarylist_:Null,boundarycutreplacements_:Null]/;(externalordering===Null&&boundarylist===Null&&boundarycutreplacements===Null||externalordering=!=Null&&boundarylist=!=Null&&boundarycutreplacements=!=Null):=Module[{adjacencymat,graph,planar,referenceperfmatch,pathmat,orderedpathmat,loopdenominator,looplist,loopreplacement,loop,loopsigns,grassmannianmatrix,sourcenodes,boundaries,boundarypaircuts,pathmatorder,neworder,newroworder,cutSequence,finalloopsignsmatrix,implementFinalLoops,globalsigns},
(*Let's first see if the graph can be embedded on genus zero*)
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
planar=False;
If[PlanarGraphQ[graph],
(*If it can be embedded on genus zero make the path matrix*)
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
(*We shall now pick an ordering of external edges for this path matrix, depending on whether the user specified an ordering or not*)
{orderedpathmat,planar}=makeOrderedPathMatrix[adjacencymat,pathmat,externalordering,topleft,topright,bottomleft,bottomright];
(*Now we have the ordered path matrix*)
(*Now we will plug in the correct signs. We begin with those belonging to loops (excluding those loops formed by closing the path between multiple boundaries)*)
(*First find the loops, if any*)
loopdenominator=Expand[1/Expand[Simplify[Det[connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]]]]];
If[Head[loopdenominator]===Plus,
(*we have multiple terms*)
looplist=-DeleteCases[List@@loopdenominator,1];
loopreplacement=MapThread[Rule,{looplist,Table[loop[iii],{iii,Length[looplist]}]}];
,looplist={};
loopreplacement={};
];
(*Now use a function to add the loop signs into the matrix*)
loopsigns=Function[{matrixentry},
Block[{terms},
If[Head[matrixentry]===Integer,
terms={matrixentry};
,If[Head[matrixentry]===Plus,
(*we have multiple terms*)
terms=Expand[Simplify[(List@@matrixentry)loopdenominator]]/loopdenominator;
,terms={Expand[Simplify[matrixentry loopdenominator]]/loopdenominator};
];
terms=terms//.loopreplacement;
terms=terms/.Map[#[[2]]->-#[[2]]&,loopreplacement];
(*If[externalordering===Null,
(*If we chose an external ordering automatically and the graph is non-planar, we need to plug in additional signs*)
If[planar===False,(*plug in signs from loops formed by going between different boundaries*)
(*PLUG IN GEKHTMAN SIGNS*)
Print["We're automatically doing a non-planar diagram!"];
];
,(*If we were given an external ordering, plug in the additional signs manually*)
Print["We're manually doing a non-planar diagram."];
];*)
];
Total[terms]]
];
(*We'll now put in the loop signs, including those from loops formed by closing the path between multiple boundaries*)
grassmannianmatrix=Map[loopsigns,orderedpathmat,{2}];
sourcenodes=Flatten[Map[Position[Transpose[orderedpathmat],#]&,IdentityMatrix[Length[orderedpathmat]]]];
If[planar==False,
If[externalordering===Null,
{boundaries,boundarypaircuts}=makeAutomaticBoundariesAndCuts[graph,topleft,topright,bottomleft,bottomright];
(*We'll need to re-rder the grassmannian nodes now that we have a new order determined by our cuts*)
pathmatorder=Flatten[DeleteCases[Join[bottomleft,Transpose[topright]],0,{2}]];
neworder=Flatten[boundaries]/.MapThread[Rule,{pathmatorder,Range[Length[pathmatorder]]}];
newroworder=Ordering[Flatten[Map[Position[neworder,#]&,sourcenodes]]];
sourcenodes=Sort[Flatten[Map[Position[neworder,#]&,sourcenodes]]];
grassmannianmatrix=grassmannianmatrix[[newroworder,neworder]];
,{boundaries,boundarypaircuts}={boundarylist,boundarycutreplacements};
];
(*This function takes a pair of external nodes and returns a list of replacement lists to be used on the grassmannian. These replacements represent all the cuts required to go from one boundary to the next*)
cutSequence=Function[{externalnodepair},
Block[{boundariestoconnect,boundarynumberrule,boundarypairnumbers,shortestpath,cutpath},
boundariestoconnect=Cases[boundaries,zz_/;MemberQ[zz,Alternatives@@externalnodepair]];
If[Length[boundariestoconnect]>1,(*the nodes are on different boundaries*)
boundarynumberrule=MapThread[Rule,{boundaries,Range[Length[boundaries]]}];
boundariestoconnect=boundariestoconnect/.boundarynumberrule;
boundarypairnumbers=Map[#[[1]]&,boundarypaircuts]/.boundarynumberrule;
(*Let's now find the shortest path between these two boundaries, using our cuts*)
shortestpath=FindShortestPath[Graph[Map[UndirectedEdge@@#&,boundarypairnumbers]],Sequence@@boundariestoconnect];
(*Turn this sequence of boundaries into pairs that can be identified with cuts*)
shortestpath=Table[{shortestpath[[iii]],shortestpath[[iii+1]]},{iii,Length[shortestpath]-1}];
(*This is the sequence of cuts we must do to go from one boundary to the other. These cuts must be performed sequentially, not all at once (in case some edges get cut multiple times)!*)
cutpath=shortestpath/.(boundarypaircuts/.boundarynumberrule);
,(*the two external nodes are on the same boundary*)
cutpath={};
];
cutpath]
];
finalloopsignsmatrix=Map[cutSequence[Intersection[Variables[#],Variables[Join[topright,bottomleft]]]]&,grassmannianmatrix,{2}];
implementFinalLoops=Function[{matrixentry,replacementlists},
Block[{newmatrixentry,ii},
newmatrixentry=matrixentry;
For[ii=1,ii<=Length[replacementlists],ii++,
newmatrixentry=newmatrixentry/.replacementlists[[ii]];
];
newmatrixentry]
];
grassmannianmatrix=MapThread[implementFinalLoops[#1,#2]&,{grassmannianmatrix,finalloopsignsmatrix},2];
];
(*We have finished putting in signs due to loops*)
(*We'll now put in the global signs on matrix entries*)
globalsigns=Partition[Map[Power[-1,Count[sourcenodes,zz_/;zz>#[[1]]&&zz<#[[2]]]]&,Map[Sort,Tuples[{sourcenodes,Range[Dimensions[grassmannianmatrix][[2]]]}]]],Dimensions[grassmannianmatrix][[2]]];
grassmannianmatrix=(grassmannianmatrix globalsigns)/.Map[#[[2]]->#[[1]]&,loopreplacement];
,(*If it cannot be embedded on genus zero,stop here*)
Print["The diagram cannot be embedded on genus zero."];
grassmannianmatrix=Null;
];
grassmannianmatrix
];

pluckerCoordinates[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,withsigns_:False]:=Module[{referenceperfmatch,Cmatrix,minors,externalvarentries,sources,sinks,putsourcesinlist,externalordering,pathmat},
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
If[withsigns,
Cmatrix=getGrassmannian[topleft,topright,bottomleft,bottomright,referencematching];
minors=Expand[Simplify[Minors[Cmatrix,Length[Cmatrix]][[1]]]];
(*Now let's find the ordering of external edges*)
externalvarentries=Map[Intersection[Variables[#],Variables[Join[bottomleft,topright]]]&,Cmatrix,{2}];
sources=Map[Intersection@@DeleteCases[#,{}]&,externalvarentries];
sinks=Map[Intersection@@#&,Transpose[externalvarentries]];
putsourcesinlist=Function[{input},Block[{return},If[input==={},return=sources[[1]];sources=Delete[sources,1];,return=input;];return]];
externalordering=Flatten[Map[putsourcesinlist[#]&,sinks]];
,pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
minors=Expand[Simplify[Minors[pathmat,Length[pathmat]][[1]]]];
externalordering=Flatten[DeleteCases[Join[bottomleft,Transpose[topright]],0,{2}]];
];
{externalordering,minors}
];


End[];
EndPackage[]
