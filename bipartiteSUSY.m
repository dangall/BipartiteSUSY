(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["BipartiteSUSY`"]

polytopeDim::usage="Takes a matrix as input and outputs the dimension of a polytope with vertices given the columns of that matrix"
joinupKasteleyn::usage="REMOVE ME FROM GLOBAL FUNCTIONS!"
totFaces::usage="Gives the TOTAL number of faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
externalFaces::usage="Gives the number of EXTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
internalFaces::usage="Gives the number of INTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
reducibilityQ::usage="Tells you whether a graph is reducible, in the scattering amplitudes sense. Set the last argument equal to True to get reducibility in the \!\(\*SubscriptBox[\(BFT\), \(2\)]\) sense"
getWeightedAdjacencyMatrix::usage="Gives the weighted adjacency matrix which can be used for WeightedAdjacencyGraph"
getAdjacencyMatrix::usage="Gives the adjacency matrix which can be used for AdjacencyGraph"
planarityQ::usage="Tells you whether a given graph can be embedded on the disk without any edges crossing"
viewGraph::usage="Shows you the graph"
duplicateEdges::usage="Returns a list of edges not appearing in a correct way in the Kasteleyn"
edgesBFTformQ::usage="Tells you whether edges are of the correct form _[_Integer,_Integer]"
consistentKasteleyn::usage="Assuming that edgesBFTformQ returns True, this function will return the list of rows and columns whose index structure violates the rules for BFTs (clockwise around white nodes and counter-clockwise around black nodes)"
checkKasteleynQ::usage="Tells you whether the Kasteleyn was inputted correctly. Its final input is optional and says whether the graph is a BFT graph (with corresponding index structure) or not."
perfectMatchings::usage="Returns the sorted list of perfect matchings. Takes as optional input whether it should check the Kasteleyn for you, and whether the graph is a BFT graph."
getPmatrix::usage="Returns the P matrix. Rows are ordered lexicographically w.r.t. edge labeling, columns are ordered according to the order given by the perfectMatchings function"
intoPolytope::usage="Returns only distinct vertices of the polytope, with their multiplicity"
matroidPolytope::usage="Returns the coordinates of the matroid polytope (some of which may have higher multiplicity than 1). Each column is the coordinate of a perfect matching."
moduliSpaceBFT::usage="Gives the moduli space of the BFT given by the Kasteleyn. It requires the input on which gauging it should use (i.e. gauging 1 or gauging 2)."
lowNumberLoopsPM::usage="Returns the number of the perfect matching with lowest multiplicity, and hence the lowest number of loops in the corresponding perfect orientation."
externalOrdering::usage="Gives a choice of external ordering of nodes, given in the form {X[i,j]\[Rule]1,X[k,l]\[Rule]2,...}."
findSources::usage="Returns a list of edges which are sources in the perfect orientation corresponding to a given reference perfect matching."
findSinks::usage="Returns a list of edges which are sinks in the perfect orientation corresponding to a given reference perfect matching."
externalEdgesNodeNumbers::usage="Takes a list of external edges and gives the Kasteleyn node numbers of the edges."
connectivityMatrix::usage="Returns the connectivity matrix of the diagram, i.e. a matrix containing all paths between all nodes."
pathMatrix::usage="Gives the path matrix, i.e. the element of the Grassmannian before any signs are placed (which ensure manifest positivity of planar diagrams)."
minorsAsPerfectMatchings::usage="Returns the minors of the pathmatrix, resembling Plucker coordinates of the Grassmannian, but without manifest-positivity signs."
dimensionGrassmannian::usage="Returns the dimension of the Grassmannian, computed by looking at the tangent space of its minors."
reducibilityBFTQ::usage="Gives the 'naive' reducibility of a graph, which is the same as the reducibility for a BFT, based on its moduli space. When gauging 2 is used, this is the same as reducibility for planar scattering diagrams."
reducibilityBFTedges::usage="Gives those edges which may be removed without affecting the moduli space, which for gauging 2 is the same as reducibility for all planar diagrams and some non-planar diagrams."
reducibilityQ::usage="Returns True or False, depending on whether the graph is reducible or not. Allows you to specify whether the graph is a BFTgraph, and if so which gaugign to use. Can correctly deal with non-planar scattering diagrams."
reducibilityEdges::usage="Returns a list of edges which may be removed without affecting the moduli space (in the case of BFTs), or the Grassmannian in the case of scattering amplitudes."
consistentEdgeRemoval::usage="Returns the full list of edges which should be consistently removed, given a choice of edge to be removed."

Begin["Private`"]


(*Basic functions that manipule and extract information from the Kasteleyn*)


joinupKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=joinupKasteleyn[topleft,topright,bottomleft,bottomright]=Join[Join[topleft,bottomleft],Join[topright,bottomright],2];

totFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
nf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
nf=Null;
];
nf
];

externalFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
externalnf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
externalnf=Null;
];
externalnf
];

internalFaces[topleft_,topright_,bottomleft_,bottomright_]:=totFaces[topleft,topright,bottomleft,bottomright]-externalFaces[topleft,topright,bottomleft,bottomright];


(*Functions useful for graph drawing and manipulation*)


getWeightedAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into a weightedadjaceny matrix*)
adjacencymatrix=Join[Join[ConstantArray[0,{Length[kasteleyn],Length[kasteleyn]}],Transpose[kasteleyn]],Join[kasteleyn,ConstantArray[0,{Dimensions[kasteleyn][[2]],Dimensions[kasteleyn][[2]]}]],2]/.{0->\[Infinity]};
adjacencymatrix
];

getAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into an adjaceny matrix*)
oneskasteleyn=kasteleyn/.Map[#->1&,Variables[kasteleyn]];
adjacencymatrix=Join[Join[ConstantArray[0,{Length[oneskasteleyn],Length[oneskasteleyn]}],Transpose[oneskasteleyn]],Join[oneskasteleyn,ConstantArray[0,{Dimensions[oneskasteleyn][[2]],Dimensions[oneskasteleyn][[2]]}]],2];
adjacencymatrix
];

viewGraph[topleft_,topright_,bottomleft_,bottomright_,showedges_:True]:=Module[{badedges,adjacencymat,kasteleyn,colors,graph,edgelist,vars,edgelabels,tempedgelabels,finalgraph,edgeweightname},
(*This needs to be a Module rather than Block, because otherwise my graph drawing at the end doesn't have access to the variable tempedgelabels!*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges==={},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We'll now make the bipartite coloring for the nodes of the graph*)
colors=MapThread[Rule,{Range[Total[Dimensions[kasteleyn]]],Join[ConstantArray[White,Length[kasteleyn]],ConstantArray[Black,Dimensions[kasteleyn][[2]]]]}];
(*We'll now get the edge list (by making a temporary graph), and use this edge list to print names on all the edges of the graph. The difficulty is largely due to giving differnt names to multiple edges going between two nodes (i.e. bubbles).*)
If[showedges==True,
graph=AdjacencyGraph[adjacencymat];
edgelist=EdgeList[graph];
vars=Variables[kasteleyn];
edgelabels=Map[Sort[(UndirectedEdge@@(Flatten[Position[kasteleyn,#]][[{1,2}]]+{0,Length[kasteleyn]}))]->#&,vars];
(*Now that we associated edges to their names, we'll make a temporary list from which we'll remove elements as they get printed onto the graph*)
tempedgelabels=edgelabels;
finalgraph=Graph[edgelist,EdgeShapeFunction->Function[{edgepositions,edgename},
edgeweightname=tempedgelabels[[Position[tempedgelabels,Sort[edgename]][[1,1]],2]];
tempedgelabels=Delete[tempedgelabels,Position[tempedgelabels,Sort[edgename]][[1,1]]];
{Text[Style[edgeweightname,Medium,Bold,Blue],Mean[edgepositions]],{Black,Line[edgepositions]}}],VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
,finalgraph=AdjacencyGraph[adjacencymat,VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
];
finalgraph
,Print["The Kasteleyn has multiple fields with the same name - can't draw the graph."];
finalgraph=Null;
];
finalgraph
];


(*Functions to check the Kasteleyn*)


duplicateEdges[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,doubleslist,kasteleynterms},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Make a list of edges that appear twice*)
doubleslist=Variables[kasteleyn][[Flatten[Position[Map[Length[Position[kasteleyn,#]]&,Variables[kasteleyn]],z_/;z>1]]]];
(*Also look for edges appearing with a minus, or with prefactors different from 1*)
kasteleynterms=Flatten[Map[MonomialList,DeleteCases[Flatten[kasteleyn],0]]];
Sort[Join[doubleslist,Variables[Complement[kasteleynterms,Variables[kasteleynterms]]]]]
];

edgesBFTformQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[z1_,z2_]/;IntegerQ[z1]&&IntegerQ[z2]]]==={}*)
Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[_Integer,_Integer]]]==={}
];

consistentKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,tocheck,rowsOK,columnsOK,consistencyviolation},
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*First check the rows of the Kasteleyn matrix corresponding to internal white nodes*)
tocheck=kasteleyn[[Range[Length[topleft]]]];
rowsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
(*Now check the columns of the Kasteleyn matrix corresponding to internal black nodes*)
tocheck=Transpose[kasteleyn[[All,Range[Dimensions[topleft][[2]]]]]];
columnsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
consistencyviolation={Flatten[Position[rowsOK,False]],Flatten[Position[columnsOK,False]]};
,consistencyviolation=Null;
];
consistencyviolation
];

checkKasteleynQ[topleft_,topright_,bottomleft_,bottomright_,BFTgraph_]:=Block[{return,badedges,indexmistakes},
return=True;
(*First check that the field hasn't been entered in twice*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges=!={},
(*if there are obvious mistakes, write them out*)
return=False;
Print["Check Kasteleyn: edges ",badedges," appear incorrectly."];
,If[BFTgraph,(*if there are no obvious mistakes, do more checks if we have a BFT graph*)
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],(*if the edges have the correct structure _[_,_] check for index mistakes*)
indexmistakes=consistentKasteleyn[topleft,topright,bottomleft,bottomright];
If[indexmistakes=!={{},{}},(*if we have index mistakes, point them out*)
return=False;
Print["There appears to be a mistake in the index structure in rows ",indexmistakes[[1]]," of the Kasteleyn."];
Print["There appears to be a mistake in the index structure in columns ",indexmistakes[[2]]," of the Kasteleyn."];
];
,return=False;(*we have a BFT with no doubles, but whose fields are not all in the right form*)
Print["Some edges have not been inputted in the correct form of _[_Integer,_Integer]"];
];
];
];
return
];


(*General functions for bipartita analysis*)


perfectMatchings[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=perfectMatchings[topleft,topright,bottomleft,bottomright]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{checkOK,externalrows,externalcolumns,rowandcolumnnumbers,rowsmergedonleftandright,newtonpolynomial,perfectmatchigns,zz},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph]
];
If[checkOK==True,
(*get all subsets of rows in bottomleft, and columns in topright*)
externalrows=Subsets[Range[Length[bottomleft]]];
externalcolumns=Subsets[Range[Length[Transpose[topright]]]];
(*Put these choices together, and only include those combinations that, when joined with topleft, leave a square matrix*)
rowandcolumnnumbers=Cases[Tuples[{externalrows,externalcolumns}],z_/;Equal@@(Map[Length,z]+Dimensions[topleft])];
(*For each case, merge topleft and the chosen rows of bottonleft. Also, merge the chosen columns of topright with the chosen columns and rows of bottomright.*)
rowsmergedonleftandright=Map[{Join[topleft,bottomleft[[#[[1]]]]],Join[topright[[All,#[[2]]]],bottomright[[#[[1]],#[[2]]]]]}&,rowandcolumnnumbers];
(*Now merge each case into a square matrix and compute its determinant. Then add up all the determinants.*)
newtonpolynomial=Total[Map[Det[Join[#[[1]],#[[2]],2]]&,rowsmergedonleftandright]];
(*Tidy up the signs, since perfect matchings are positive*)
perfectmatchigns=Sort[MonomialList[newtonpolynomial]/.{Times[-1,zz_]->Times[zz]}];
,perfectmatchigns=Null;
];
perfectmatchigns
];

getPmatrix[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*getPmatrix[topleft,topright,bottomleft,bottomright]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{varlist,plist,pmatrix},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
plist=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[plist=!=Null,
pmatrix=Table[MemberQ[Variables[plist[[jjj]]],varlist[[iii]]],{iii,Length[varlist]},{jjj,Length[plist]}]/.{True->1,False->0};
,pmatrix=Null;
];
pmatrix
];

matroidPolytope[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*matroidPolytope[topleft,topright,bottomleft,bottomright]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{pmatrix,externaledges,externalrows,matroidpoly},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
(*Only select those rows corresponding to external edges in the graph*)
externaledges=Variables[Join[bottomleft,topright]];
externalrows=Flatten[Position[Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]],Alternatives@@externaledges]];
matroidpoly=pmatrix[[externalrows]];
,matroidpoly=Null;
];
matroidpoly
];

moduliSpaceBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1||gauging===2):=Block[{modulispace,matrixP,chargesFterm,gaugeCharge,edges,intfaces,gaugechargematrix,chargesDterm},
If[gauging==2,
modulispace=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
,If[gauging==1,
(*gauging 1 only works for graphs of BFT type, i.e. where the edges are labeled according to the faces they touch*)
matrixP=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,True];
If[matrixP=!=Null,
chargesFterm=NullSpace[matrixP];
gaugeCharge=Function[{edge,column},Block[{output=0},If[edge[[1]]==column,output=output+1;];If[edge[[2]]==column,output=output-1;];output]];
edges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
intfaces=internalFaces[topleft,topright,bottomleft,bottomright];
gaugechargematrix=Table[gaugeCharge[edges[[iii]],jjj],{iii,Length[edges]},{jjj,intfaces}];
chargesDterm=Transpose[LinearSolve[matrixP,gaugechargematrix]];
modulispace=NullSpace[Join[chargesFterm,chargesDterm]];
,modulispace=Null;
];
];
];
modulispace
];

polytopeDim[mat_]:=Block[{dimension,newmat},
If[MemberQ[Transpose[mat],ConstantArray[0,Length[mat]]],
(*If the matrix has a column of zeros, the matrix rank gives you the dimension. Otherwise you need to shift the matrix so that a vertex is at the origin.*)
dimension=MatrixRank[mat];
,newmat=mat-mat[[All,1]];(*this operation automatically threads over all the columns of the matrix.*)
dimension=MatrixRank[newmat];
];
dimension
];

intoPolytope[mat_]:=Block[{columnsandmultiplicity,polytope,multiplicity},
columnsandmultiplicity=Tally[Transpose[mat]];
polytope=Transpose[Map[#[[1]]&,columnsandmultiplicity]];
multiplicity=Map[#[[2]]&,columnsandmultiplicity];
{polytope,multiplicity}
];

lowNumberLoopsPM[topleft_,topright_,bottomleft_,bottomright_]:=Block[{matroidpoly,multiplicitypolytope,perfmatchnumber},
matroidpoly=matroidPolytope[topleft,topright,bottomleft,bottomright];
multiplicitypolytope=intoPolytope[matroidpoly];
perfmatchnumber=Position[Transpose[matroidpoly],multiplicitypolytope[[1]][[All,Ordering[multiplicitypolytope[[2]]][[1]]]]][[1,1]];
perfmatchnumber
];

reducibilityBFTQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,reducibility},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]],reducibility=True;,reducibility=False;];
,reducibility=Null;
];
reducibility
];

reducibilityBFTedges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,problemlines,reducibilityedges},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
problemlines=Flatten[Position[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]]];
reducibilityedges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]][[problemlines]];
,reducibilityedges=Null;
];
reducibilityedges
];

consistentEdgeRemoval[topleft_,topright_,bottomleft_,bottomright_,edgelist_,checkneeded_:False,BFTgraph_:False]:=Block[{varlist,rowstokill,pmatrix,survivingcolums,reducedpmatrix,consistentedgelist},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
rowstokill=Flatten[Position[varlist,Alternatives@@edgelist]];
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
survivingcolums=Complement[Range[Dimensions[pmatrix][[2]]],Map[#[[2]]&,Position[pmatrix[[rowstokill]],1]]];
reducedpmatrix=pmatrix[[All,survivingcolums]];
consistentedgelist=varlist[[Flatten[Position[reducedpmatrix,ConstantArray[0,Dimensions[reducedpmatrix][[2]]]]]]];
,consistentedgelist=Null;
];
consistentedgelist
];



(*Functions useful for scattering amplitudes*)


planarityQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymat,graph,planar,externals,extnum,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
(*If the graph can be embedded on genus zero, try and see if we can do so with only one boundary*)
planar=False;(*assume the graph is non-planar until proven otherwise*)
If[PlanarGraphQ[graph],
externals=Flatten[Position[Map[Total,adjacencymat],1]];(*These are the row-numbers corresponding to external nodes*)
extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
permutations=Map[Append[#[[1]],extnum]&,Gather[Permutations[Range[extnum-1]],#1==Reverse[#2]&]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],
planar=True;
Break[];
];
];
];
planar
];

externalOrdering[topright_,bottomleft_]:=Block[{ordering},
ordering=Flatten[DeleteCases[Join[bottomleft,topright],0,{2}]];
ordering=MapThread[Rule,{ordering,Range[Length[ordering]]}];
ordering
];

findSources[topright_,bottomleft_,referenceperfmatch_]:=Block[{referencevars,sourceedges},
referencevars=Variables[referenceperfmatch];
(*Sources are those variables in the bottomleft that are not in referenceperfmatch, and those in topright which are*)
sourceedges=Union[Complement[DeleteCases[Flatten[bottomleft],0],referencevars],Intersection[DeleteCases[Flatten[topright],0],referencevars]];
sourceedges
];

findSinks[topright_,bottomleft_,referenceperfmatch_]:=Block[{perfmatchvars,sinkedges},
perfmatchvars=Variables[referenceperfmatch];
(*Sinks are those variables in the bottomleft that are in referenceperfmatch, and those in topright which are not*)
sinkedges=Union[Complement[DeleteCases[Flatten[topright],0],perfmatchvars],Intersection[DeleteCases[Flatten[bottomleft],0],perfmatchvars]];
sinkedges
];

externalEdgesNodeNumbers[topleft_,topright_,bottomleft_,bottomright_,externaledgelist_]:=Union[Map[#[[1]]&,Position[bottomleft,Alternatives@@externaledgelist]+Length[topleft]],Map[#[[2]]&,Position[topright,Alternatives@@externaledgelist]+Total[Dimensions[topleft]]+Length[bottomleft]]];

connectivityMatrix[topleft_,topright_,bottomleft_,bottomright_,referenceperfmatch_]:=connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]=Block[{kasteleyn,perfmatchvars,kastnopm,kastinvertedpm,bigmatrix,connectivitymat},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
perfmatchvars=Variables[referenceperfmatch];
(*We need to first form a large matrix based on the Kasteleyn, and then take its inverse*)
kastnopm=-(kasteleyn/.Map[#->0&,perfmatchvars]);
kastinvertedpm=-Transpose[kasteleyn/.Join[Map[#->1/#&,perfmatchvars],Map[#->0&,Complement[Variables[kasteleyn],perfmatchvars]]]];
bigmatrix=Join[Join[IdentityMatrix[Length[kasteleyn]],kastinvertedpm],Join[kastnopm,IdentityMatrix[Dimensions[kasteleyn][[2]]]],2];
connectivitymat=Inverse[bigmatrix];
connectivitymat
];

pathMatrix[topleft_,topright_,bottomleft_,bottomright_,referenceperfmatch_]:=Block[{bigpathmatrix,externalrows,externalcolumns,finalpathmatrix},
bigpathmatrix=connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
(*bigpathmatrix contains the connectivity between ALL pairs of nodes. We need to select those entries corresponding to sources goign to external nodes.*)
externalrows=externalEdgesNodeNumbers[topleft,topright,bottomleft,bottomright,findSources[topright,bottomleft,referenceperfmatch]];
externalcolumns=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];
finalpathmatrix=Expand[Simplify[bigpathmatrix[[externalrows,externalcolumns]]]];
(*The determinant of bigpathmatrix gives the loop factor in the paths between external nodes.*)
finalpathmatrix
];

minorsAsPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright]=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright,referencematching]=Block[{referenceperfmatch,pathmat,minors,loopdenominator,truemapminortoperfmatch},
(*If we haven't selected a specific perfect matching, choose one with lowest possible multiplicity*)
If[referencematching===Null,
referenceperfmatch=perfectMatchings[topleft,topright,bottomleft,bottomright][[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=referencematching;
];
pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
minors=Minors[pathmat,Length[pathmat]][[1]];
loopdenominator=Expand[referenceperfmatch/Expand[Simplify[Det[connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]]]]];
truemapminortoperfmatch=Expand[Simplify[minors loopdenominator]];
truemapminortoperfmatch
];

dimensionGrassmannian[topleft_,topright_,bottomleft_,bottomright_]:=dimensionGrassmannian[topleft,topright,bottomleft,bottomright]=Block[{minorexpressions,minorvars,tangentspacedim},
minorexpressions=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright];
minorvars=Variables[minorexpressions];
(*When computing the tangent space we need to subtract 1, because Plucker coordinates are projective variables*)
tangentspacedim=MatrixRank[Table[D[minorexpressions[[iii]],minorvars[[jjj]]],{iii,Length[minorexpressions]},{jjj,Length[minorvars]}]]-1;
tangentspacedim
];

reducibilityQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{edgesnaivereducibility,reducibility,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibility=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibility=False;
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibility=True;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
If[polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright]]>dimensionGrassmannian[topleft,topright,bottomleft,bottomright],
(*if the dimension of the Grassmannian is less than that from a naive counting of edges and perfect matchings, it is necessarily possible to remove edges without affecting the Grassmannian*)
reducibility=True;
,reducibility=False;
(*assume the graph is not reducible until you find an edge which, when removed, does not reduce the dimension*)
For[ii=1,ii<=Length[edgesnaivereducibility],ii++,
dimafteredgeremoval=dimensionGrassmannian[topleft/.{edgesnaivereducibility[[ii]]->0},topright/.{edgesnaivereducibility[[ii]]->0},bottomleft/.{edgesnaivereducibility[[ii]]->0},bottomright];
If[dimafteredgeremoval==dimgrassmannian,
(*we have found an edge which may be removed without decreasing the dimension of the Grassmannian!*)
reducibility=True;
Break[]
];
];
];
];
];
];
reducibility
];

reducibilityEdges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1||gauging===2):=Block[{edgesnaivereducibility,reducibilityedgelist,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibilityedgelist=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibilityedgelist={};
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibilityedgelist=edgesnaivereducibility;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
(*Just select those edgs which, when removed, do not decrease the dimension of the Grassmannian*)
reducibilityedgelist=Cases[edgesnaivereducibility,zz_/;dimensionGrassmannian[topleft/.{zz->0},topright/.{zz->0},bottomleft/.{zz->0},bottomright]==dimgrassmannian];
];
];
];
reducibilityedgelist
];


End[];
EndPackage[]
