(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["BipartiteSUSY`"]

polytopeDim::usage="Takes a matrix as input and outputs the dimension of a polytope with vertices given the columns of that matrix."
joinupKasteleyn::usage="Forms a single matrix from the four components of the Kasteleyn matrix."
totFaces::usage="Gives the TOTAL number of faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)."
externalFaces::usage="Gives the number of EXTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)."
internalFaces::usage="Gives the number of INTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)."
allFaceLabels::usage="Gives the name of the faces in the graph."
externalFaceLabels::usage="Gives the name of the EXTERNAL faces in the graph."
internalFaceLabels::usage="Gives the name of the INTERNAL faces in the graph."
(*reducibilityQ::usage="Tells you whether a graph is reducible, in the scattering amplitudes sense. Set the last argument equal to True to get reducibility in the Subscript[BFT, 2] sense"*)
getWeightedAdjacencyMatrix::usage="Gives the weighted adjacency matrix which can be used for WeightedAdjacencyGraph"
getAdjacencyMatrix::usage="Gives the adjacency matrix which can be used for AdjacencyGraph"
getOrientedAdjacencyMatrix::usage="Gives the adjacency matrix of the graph directed according to a specified perfect orientation. The user specifies whether the output should be in terms of edge weights or not."
planarityQ::usage="Tells you whether a given graph can be embedded on the disk without any edges crossing"
viewGraph::usage="Shows you the graph"
duplicateEdges::usage="Returns a list of edges not appearing in a correct way in the Kasteleyn"
edgesBFTformQ::usage="Tells you whether edges are of the correct form _[_Integer,_Integer]"
consistentKasteleyn::usage="Assuming that edgesBFTformQ returns True, this function will return the list of rows and columns whose index structure violates the rules for BFTs (clockwise around white nodes and counter-clockwise around black nodes)"
checkKasteleynQ::usage="Tells you whether the Kasteleyn was inputted correctly. Its final input is optional and says whether the graph is a BFT graph (with corresponding index structure) or not."
perfectMatchings::usage="Returns the sorted list of perfect matchings. Takes as optional input whether it should check the Kasteleyn for you, and whether the graph is a BFT graph."
getPmatrix::usage="Returns the P matrix. Rows are ordered lexicographically w.r.t. edge labeling, columns are ordered according to the order given by the perfectMatchings function"
intoPolytope::usage="Returns only distinct vertices of the polytope, with their multiplicity"
matroidPolytope::usage="Returns the coordinates of the matroid polytope (some of which may have higher multiplicity than 1). Each column is the coordinate of a perfect matching."
moduliSpaceBFT::usage="Gives the moduli space of the BFT given by the Kasteleyn. It requires the input on which gauging it should use (i.e. gauging 1 or gauging 2)."
lowNumberLoopsPM::usage="Returns the number of the perfect matching with lowest multiplicity, and hence the lowest number of loops in the corresponding perfect orientation."
externalEdgeOrderingDefault::usage="Gives a choice of ordering of external edges, given in the form {X[i,j]\[Rule]1,X[k,l]\[Rule]2,...}. Only contains those edges which are present in the graph."
externalNodeOrderingDefault::usage="Gives a choice of ordering of external nodes. Also contains external nodes with no external edge attached to it."
findSourceEdges::usage="Returns a list of edges which are sources in the perfect orientation corresponding to a given reference perfect matching."
findSinkEdges::usage="Returns a list of edges which are sinks in the perfect orientation corresponding to a given reference perfect matching."
findSourceNodes::usage="Returns a list of nodes which are sources in the perfect orientation corresponding to a given reference perfect matching."
findSinkNodes::usage="Returns a list of nodes which are sinks in the perfect orientation corresponding to a given reference perfect matching."
externalEdgesNodeNumbers::usage="Takes a list of external edges and gives the Kasteleyn node numbers of the edges."
connectivityMatrix::usage="Returns the connectivity matrix of the diagram, i.e. a matrix containing all paths between all nodes."
traditionalConnectivityMatrix::usage="Returns the connectivity matrix of the diagram, computed using the method described in 1310.3820, which involves the inverse of a particular adjacency matrix."
traditionalPathMatrix::usage="Gives the path matrix, i.e. the element of the Grassmannian before any signs are placed (which ensure manifest positivity of planar diagrams), by using the traditionalConnectivityMatrix method, which involves the inverse of a matrix."
pathMatrix::usage="Gives the path matrix, i.e. the element of the Grassmannian before any signs are placed (which ensure manifest positivity of planar diagrams)."
getLoopDenominator::usage="Returns the sum of loops contributing to terms in the denominator of terms in the path matrix. Is of the form (1-loops). The user may specify to have it in the form (1+loops)."
minorsAsPerfectMatchings::usage="Returns the minors of the pathmatrix, resembling Plucker coordinates of the Grassmannian, but without manifest-positivity signs."
dimensionGrassmannian::usage="Returns the dimension of the Grassmannian, computed by looking at the tangent space of its minors."
reducibilityBFTQ::usage="Gives the 'naive' reducibility of a graph, which is the same as the reducibility for a BFT, based on its moduli space. When gauging 2 is used, this is the same as reducibility for planar scattering diagrams."
reducibilityBFTedges::usage="Gives those edges which may be removed without affecting the moduli space, which for gauging 2 is the same as reducibility for all planar diagrams and some non-planar diagrams."
reducibilityQ::usage="Returns True or False, depending on whether the graph is reducible or not. Allows you to specify whether the graph is a BFTgraph, and if so which gauging to use. Can correctly deal with non-planar scattering diagrams."
reducibilityEdges::usage="Returns a list of edges which may be removed without affecting the moduli space (in the case of BFTs), or the Grassmannian in the case of scattering amplitudes."
consistentEdgeRemoval::usage="Returns the full list of edges which should be consistently removed, given a choice of edge to be removed."
survivingPerfectMatchings::usage="Gives you a list of which perfect-matching numbers survive after removing a given set of edges."
reductionGraphBFT::usage="Returns a list where each element is a set of edges which may be removed from the graph without affecting the moduli space  (in the case of BFTs) under a certain guaging, or matroid polytope (in the case of scattering amplitudes)."
reductionGraph::usage="Returns the sets of edges which may be removed without changing any of the physics. Is valid both for BFTs as well as planar and non-planar on-shell diagrams."
nonPluckerPolesQ::usage="Tells you whether a reduced diagram has non-standard poles which are not simply products of Plucker coordinates."
removableEdges::usage="Returns the list of removable edges. If checkneeded=True, it will also check if the starting graph is reduced or not."
edgeOrderings::usage="Returns a list where each element is a consistent ordering of edges around a white or black node, i.e. where the edges are sequenced such that each subsequent edge's first index is equal to the previous edge's second index."
cyclicEdgeOrderings::usage="Retuns a list of edges where the edges have been ordered accoring to the cyclic order, i.e. i.e. where the edges are sequenced such that each subsequent edge's first index is equal to the previous edge's second index."
(*nextStepBlackToWhite::usage="Returns the next edge in the zig-zag path and its position."*)
(*nextStepWhiteToBlack::usage="Returns the next edge in the zig-zag path and its position."*)
(*nextStepWhiteToBlackInternalZigzag::usage="Returns the next edge in the internal zig-zag path and its position."*)
(*nextStepBlackToWhiteInternalZigzag::usage="Returns the next edge in the internal zig-zag path and its position."*)
(*internalZigZagNumeratorDenominator::usage="Returns a list where the first element is a list of edges in the numerator of a zig-zag path, and the second element is a list of edges in the denominator of the zig-zag path. The zig-zag path starts from an edge."*)
allZigZagNumeratorsDenominators::usage="Returns a list where each element corresponds to a zig-zag path. The information is given as a list of two elements, where the first element contains all variables in the numerator of the expression, and the second element contains the variables in the denominator. Assumes standard rules: turn left at white nodes and right at black nodes, and edges from white to black are in the numerator, and vice-versa."
makeZigZags::usage="Returns a list of zig-zag paths. Edges in the numerator are directed from white to black nodes, edges in the denominator are directed from black to white nodes. The standard rule is to turn left at white nodes and right at black nodes; it's possible to choose the opposite option by setting the (optional) final argument to True."
selfIntersectingZigZagsQ::usage="Tells you whether the graph has self-intersecting zig-zag paths. Returns True or False."
badDoubleCrossingZigZagPairs::usage="Returns a list of pairs of zig-zags that have 'bad double crossings'. Every element contains a pair of lists of edges representing two zig-zags that have a bad double crossing."
badDoubleCrossingZigZagQ::usage="Tells you whether the graph has 'bad double crossings'."
zigZagsAsPerfectMatchings::usage="Returns a list where each element consists of pairs of perfect matchings. The first perfect matching divided by the second one equals a given zig-zag. Since there may be multiple alternatives to reach the same zig-zag, each element in the returned list may contain multiple pairs."
matroidQ::usage="Tells you whether the inputted list of elements is a matroid or not."
matroidViolationCheck::usage="Returns a list of pairs of matroid elements that do not satisfy the exchange axiom."
pluckerRelations::usage="Returns a list of (generally not independent) Plucker relations. Each Plucker coordinate has the protected form minor[i,j,...]. It is necessary to act with ReleaseHold on the output of pluckerRelations to allow minor[i,j,...] etc. to take on predefined values."
independentPluckerRelations::usage="Returns a list with two elements: the first contains a list of all independent Plucker relations, and the second contains the solution to these equations."
(*We have to be able to bring the HoldForm[minor] out of the the package*)
minor::usage=""
(*makeOrderedPathMatrix::usage="This function returns the pathmatrix where, when possible, the external nodes have a cyclic planar ordering."*)
(*spiralInList::usage="This function takes a list of vertices and orders them according to the spiralling-in order."*)
(*rotateExternalVertices::usage="This function rotates external vertices when a cut goes parallelly over the external edge."*)
(*makePlanarGraph::usage="Returns the vertex coordinates and edges (with their coordinates) of the graph drawn on genus zero, drawn ideally for the construction of unproblematic cuts between external boundaries."*)
(*makeAutomaticBoundariesAndCuts::usage="This function returns a list of boundaries, corresponding to each external node, and cuts between these boundaries."*)
getGrassmannian::usage="This function returns the correspdoning element of the Grassmannian with all signs placed correctly to ensure manifest positivity of minors in planar diagrams, including signs associated to the rotation numnber of paths in the diagram. It only works when the graph can be embedded on genus zero (though it may have any number of boundaries)."
pluckerCoordinates::usage="Returns the external ordering and the Plucker coordinates of the on-shell diagram. It is posisble to specify whether this function should place in all signs according to the boundary measurement, or whether the path matrix is sufficient."
makeLoopVariablesBasis::usage="Returns a list of paths that form a basis with which it is possible to express any path in the graph. The output is of the form of two lists: the first one contains the internal faces, and if the optional input 'standardfacevariables' is False it also contains non-trivial cycles around surfaces with non-zero genus as well as products of external faces which circle around a boundary. The first list will generically be a linear combination of these paths. The second entry contains the remaining independent external faces, paths going between different boundaries, and if 'standardfacevariables' is True it also contains non-trivial cycles for non-zero genus."
moduliLoopVariablesBFT::usage="Returns a list of three items: the first is the master space, the second is the moduli space, and the third is the loop variable basis used to make these spaces."
externalEdgeOrderingGrassmanian::usage="Returns the ordering of external edges chosen by default by getGrassmannian. Only contains those edges which are present in the Kasteleyn."
externalNodeOrderingGrassmanian::usage="Returns the ordering of external nodes chosen by default by getGrassmannian."
getStratification::usage="Returns a list of boundaries in the stratification. The elements are ordered by dimensionality, with the first element containing the top-dimensional boundaries and the last containing the zero-dimensional boundaries. The boundaries in each element are expressed as lists, each list containing move-equivalent configurations. The configurations are expressed as a list of edges which are present in the graph."
getStratificationNumbers::usage="Returns the number of boundaries of each dimensionality, beginning with the highest dimension and ending in the number of zero-dimensional boundaries."
getEulerNumber::usage="Gives the Euler number of the stratification of the graph."
getFaceLattice::usage="Returns a list of boundaries of the matching polytope. The elements are ordered by dimensionality, with the first element containing the top-dimensional boundaries and the last containing the zero-dimensional boundaries. Each boundary is expressed as a list of edges which are present in the graph."
getStratificationGraph::usage="Returns the graph containing the full stratification of the graph in question, with all the connectivity between the boundaries of various dimensionality. The best way to view it is to view it using the option GraphLayout\[Rule]\"LayeredDigraphEmbedding\" (the user must do this as a second step, with the graph that this function returns)."
getFaceLatticeGraph::usage="Returns the graph containing the full face lattive of the graph in question, with all the connectivity between the boundaries of various dimensionality. The best way to view it is to view it using the option GraphLayout\[Rule]\"LayeredDigraphEmbedding\" (the user must do this as a second step, with the graph that this function returns)."
nonTrivialPoles::usage="Returns a list containing possible relations among Plucker coordinates that do not follow from the Plucker relations."

Begin["Private`"]


(*Basic functions that manipule and extract information from the Kasteleyn*)


joinupKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=joinupKasteleyn[topleft,topright,bottomleft,bottomright]=Join[Join[topleft,bottomleft],Join[topright,bottomright],2];

totFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
nf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
nf=Null;
];
nf
];

externalFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
externalnf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
externalnf=Null;
];
(*If there are external nodes with no edges attached to them, assume they are all in the same face, and declare this face to be external*)
If[externalnf===0&&(Length[bottomleft]+Length[Transpose[topright]])>0,
externalnf=1;
];
externalnf
];

internalFaces[topleft_,topright_,bottomleft_,bottomright_]:=totFaces[topleft,topright,bottomleft,bottomright]-externalFaces[topleft,topright,bottomleft,bottomright];

allFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
facelist=Null;
];
facelist
];

externalFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
facelist=Null;
];
(*If there are external nodes with no edges attached to them, assume they are all in the same face, and declare this face to be external*)
If[facelist==={}&&(Length[bottomleft]+Length[Transpose[topright]])>0,
facelist={Last[Union[Flatten[List@@@Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]]]]};
];
facelist
];

internalFaceLabels[topleft_,topright_,bottomleft_,bottomright_]:=Complement[allFaceLabels[topleft,topright,bottomleft,bottomright],externalFaceLabels[topleft,topright,bottomleft,bottomright]];


(*Functions useful for graph drawing and manipulation*)


getWeightedAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into a weightedadjaceny matrix*)
adjacencymatrix=Join[Join[ConstantArray[0,{Length[kasteleyn],Length[kasteleyn]}],Transpose[kasteleyn]],Join[kasteleyn,ConstantArray[0,{Dimensions[kasteleyn][[2]],Dimensions[kasteleyn][[2]]}]],2]/.{0->\[Infinity]};
adjacencymatrix
];

getAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into an adjaceny matrix*)
oneskasteleyn=kasteleyn/.Map[#->1&,Variables[kasteleyn]];
adjacencymatrix=Join[Join[ConstantArray[0,{Length[oneskasteleyn],Length[oneskasteleyn]}],Transpose[oneskasteleyn]],Join[oneskasteleyn,ConstantArray[0,{Dimensions[oneskasteleyn][[2]],Dimensions[oneskasteleyn][[2]]}]],2];
adjacencymatrix
];

getOrientedAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,withedgeweights_:False]:=Block[{perfmatchings,referenceperfmatch,kasteleyn,turnoffreferencevars,turnoffothervars,adjacencymat},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
(*We'll make a graph oriented according to the perfect orientation associatedd to the perfect matching referencematching. Let's start with making all edges point from white to black.*)
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
turnoffreferencevars=Map[#->0&,Variables[referenceperfmatch]];
turnoffothervars=Map[#->0&,Complement[Variables[kasteleyn],Variables[referenceperfmatch]]];
(*Now we'll make the adjacency matrix, but which still contains the names of the edges. Those edges that are in the perfect matching should be oppositely oriented*)
adjacencymat=Join[Join[Table[0,{iii,Length[kasteleyn]},{jjj,Length[kasteleyn]}],Transpose[kasteleyn]/.turnoffothervars],Join[kasteleyn/.turnoffreferencevars,Table[0,{iii,Dimensions[kasteleyn][[2]]},{jjj,Dimensions[kasteleyn][[2]]}]],2];
If[withedgeweights==False,
adjacencymat=adjacencymat/.Map[#->1&,Variables[kasteleyn]];
];
,Print["This graph has no perfect matchings"];
adjacencymat=Null;
];
adjacencymat
];

viewGraph[topleft_,topright_,bottomleft_,bottomright_,showedges_:True]:=Module[{badedges,adjacencymat,kasteleyn,colors,graph,edgelist,vars,edgelabels,tempedgelabels,finalgraph,edgeweightname},
(*This needs to be a Module rather than Block, because otherwise my graph drawing at the end doesn't have access to the variable tempedgelabels!*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges==={},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We'll now make the bipartite coloring for the nodes of the graph*)
colors=MapThread[Rule,{Range[Total[Dimensions[kasteleyn]]],Join[ConstantArray[White,Length[kasteleyn]],ConstantArray[Black,Dimensions[kasteleyn][[2]]]]}];
(*We'll now get the edge list (by making a temporary graph), and use this edge list to print names on all the edges of the graph. The difficulty is largely due to giving differnt names to multiple edges going between two nodes (i.e. bubbles).*)
If[showedges==True,
graph=AdjacencyGraph[adjacencymat];
edgelist=EdgeList[graph];
vars=Variables[kasteleyn];
edgelabels=Map[Sort[(UndirectedEdge@@(Flatten[Position[kasteleyn,#]][[{1,2}]]+{0,Length[kasteleyn]}))]->#&,vars];
(*Now that we associated edges to their names, we'll make a temporary list from which we'll remove elements as they get printed onto the graph*)
tempedgelabels=edgelabels;
finalgraph=Graph[graph,EdgeShapeFunction->Function[{edgepositions,edgename},
edgeweightname=tempedgelabels[[Position[tempedgelabels,Sort[edgename]][[1,1]],2]];
tempedgelabels=Delete[tempedgelabels,Position[tempedgelabels,Sort[edgename]][[1,1]]];
{Text[Style[edgeweightname,Medium,Bold,Blue],Mean[edgepositions]],{Black,Line[edgepositions]}}],VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
,finalgraph=AdjacencyGraph[adjacencymat,VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
];
finalgraph
,Print["The Kasteleyn has multiple fields with the same name - can't draw the graph."];
finalgraph=Null;
];
finalgraph
];


(*Functions to check the Kasteleyn*)


duplicateEdges[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,doubleslist,kasteleynterms},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Make a list of edges that appear twice*)
doubleslist=Variables[kasteleyn][[Flatten[Position[Map[Length[Position[kasteleyn,#]]&,Variables[kasteleyn]],z_/;z>1]]]];
(*Also look for edges appearing with a minus, or with prefactors different from 1*)
kasteleynterms=Flatten[Map[MonomialList,DeleteCases[Flatten[kasteleyn],0]]];
Sort[Join[doubleslist,Variables[Complement[kasteleynterms,Variables[kasteleynterms]]]]]
];

edgesBFTformQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[_Integer,_Integer]]]==={}
];

consistentKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,tocheck,rowsOK,columnsOK,consistencyviolation},
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*First check the rows of the Kasteleyn matrix corresponding to internal white nodes*)
tocheck=kasteleyn[[Range[Length[topleft]]]];
rowsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
(*Now check the columns of the Kasteleyn matrix corresponding to internal black nodes*)
tocheck=Transpose[kasteleyn[[All,Range[Dimensions[topleft][[2]]]]]];
columnsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
consistencyviolation={Flatten[Position[rowsOK,False]],Flatten[Position[columnsOK,False]]};
,consistencyviolation=Null;
];
consistencyviolation
];

checkKasteleynQ[topleft_,topright_,bottomleft_,bottomright_,BFTgraph_]:=Block[{return,badedges,indexmistakes},
return=True;
(*First check that the field hasn't been entered in twice*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges=!={},
(*if there are obvious mistakes, write them out*)
return=False;
Print["Check Kasteleyn: edges ",badedges," appear incorrectly."];
,If[BFTgraph,(*if there are no obvious mistakes, do more checks if we have a BFT graph*)
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],(*if the edges have the correct structure _[_,_] check for index mistakes*)
indexmistakes=consistentKasteleyn[topleft,topright,bottomleft,bottomright];
If[indexmistakes=!={{},{}},(*if we have index mistakes, point them out*)
return=False;
Print["There appears to be a mistake in the index structure in rows ",indexmistakes[[1]]," of the Kasteleyn."];
Print["There appears to be a mistake in the index structure in columns ",indexmistakes[[2]]," of the Kasteleyn."];
];
,return=False;(*we have a BFT with no doubles, but whose fields are not all in the right form*)
Print["Some edges have not been inputted in the correct form of _[_Integer,_Integer]"];
];
];
];
return
];


(*General functions for bipartita analysis*)


perfectMatchings[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=perfectMatchings[topleft,topright,bottomleft,bottomright]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{checkOK,externalrows,externalcolumns,rowandcolumnnumbers,rowsmergedonleftandright,newtonpolynomial,perfectmatchigns,zz},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
(*get all subsets of rows in bottomleft, and columns in topright*)
externalrows=Subsets[Range[Length[bottomleft]]];
externalcolumns=Subsets[Range[Length[Transpose[topright]]]];
(*Put these choices together, and only include those combinations that, when joined with topleft, leave a square matrix*)
rowandcolumnnumbers=Cases[Tuples[{externalrows,externalcolumns}],z_/;Equal@@(Map[Length,z]+Dimensions[topleft])];
(*For each case, merge topleft and the chosen rows of bottonleft. Also, merge the chosen columns of topright with the chosen columns and rows of bottomright.*)
rowsmergedonleftandright=Map[{Join[topleft,bottomleft[[#[[1]]]]],Join[topright[[All,#[[2]]]],bottomright[[#[[1]],#[[2]]]]]}&,rowandcolumnnumbers];
(*Now merge each case into a square matrix and compute its determinant. Then add up all the determinants.*)
newtonpolynomial=Total[Map[Det[Join[#[[1]],#[[2]],2]]&,rowsmergedonleftandright]];
(*Tidy up the signs, since perfect matchings are positive*)
perfectmatchigns=Sort[MonomialList[newtonpolynomial]/.{Times[-1,zz_]->Times[zz]}];
If[perfectmatchigns==={0},(*in case there are no perfect matchings*)
perfectmatchigns={};
];
,perfectmatchigns=Null;
];
perfectmatchigns
];

getPmatrix[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=getPmatrix[topleft,topright,bottomleft,bottomright]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{varlist,plist,pmatrix},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
plist=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[plist=!=Null,
pmatrix=Table[MemberQ[Variables[plist[[jjj]]],varlist[[iii]]],{iii,Length[varlist]},{jjj,Length[plist]}]/.{True->1,False->0};
,pmatrix=Null;
];
pmatrix
];

survivingPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,edgelist_,checkneeded_:False,BFTgraph_:False]:=Block[{varlist,rowstokill,pmatrix,survivingcolums},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
rowstokill=Flatten[Position[varlist,Alternatives@@edgelist]];
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
survivingcolums=Complement[Range[Dimensions[pmatrix][[2]]],Map[#[[2]]&,Position[pmatrix[[rowstokill]],1]]];
,survivingcolums=Null;
];
survivingcolums
];

matroidPolytope[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=matroidPolytope[topleft,topright,bottomleft,bottomright]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{pmatrix,externaledges,externalrows,matroidpoly},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
(*Only select those rows corresponding to external edges in the graph*)
externaledges=Variables[Join[bottomleft,topright]];
externalrows=Flatten[Position[Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]],Alternatives@@externaledges]];
matroidpoly=pmatrix[[externalrows]];
If[matroidpoly==={},
matroidpoly={ConstantArray[0,Dimensions[pmatrix][[2]]]};
];
,matroidpoly=Null;
];
matroidpoly
];

moduliSpaceBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{modulispace,matrixP,chargesFterm,gaugeCharge,edges,intfaces,gaugechargematrix,chargesDterm},
If[gauging==2,
modulispace=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
,If[gauging==1,
(*gauging 1 only works for graphs of BFT type, i.e. where the edges are labeled according to the faces they touch*)
matrixP=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,True];
If[matrixP=!=Null,
If[Dimensions[matrixP][[2]]>0,
chargesFterm=NullSpace[matrixP];
gaugeCharge=Function[{edge,column},Block[{output=0},If[edge[[1]]==column,output=output+1;];If[edge[[2]]==column,output=output-1;];output]];
edges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
intfaces=internalFaceLabels[topleft,topright,bottomleft,bottomright];
If[intfaces=!={},
gaugechargematrix=Table[gaugeCharge[edges[[iii]],intfaces[[jjj]]],{iii,Length[edges]},{jjj,Length[intfaces]}];
chargesDterm=Transpose[LinearSolve[matrixP,gaugechargematrix]];
,chargesDterm={};
];
modulispace=NullSpace[Join[chargesFterm,chargesDterm]];
,modulispace={{}};
];
,modulispace=Null;
];
];
];
modulispace
];

polytopeDim[mat_]:=Block[{dimension,newmat},
If[MemberQ[Dimensions[mat],0],
dimension=0;
,If[MemberQ[Transpose[mat],ConstantArray[0,Length[mat]]],
(*If the matrix has a column of zeros, the matrix rank gives you the dimension. Otherwise you need to shift the matrix so that a vertex is at the origin.*)
dimension=MatrixRank[mat];
,newmat=mat-mat[[All,1]];(*this operation automatically threads over all the columns of the matrix.*)
dimension=MatrixRank[newmat];
];
];
dimension
];

intoPolytope[mat_]:=Block[{columnsandmultiplicity,polytope,multiplicity},
columnsandmultiplicity=Tally[Transpose[mat]];
polytope=Transpose[Map[#[[1]]&,columnsandmultiplicity]];
multiplicity=Map[#[[2]]&,columnsandmultiplicity];
{polytope,multiplicity}
];

lowNumberLoopsPM[topleft_,topright_,bottomleft_,bottomright_]:=Block[{matroidpoly,multiplicitypolytope,perfmatchnumber},
matroidpoly=matroidPolytope[topleft,topright,bottomleft,bottomright];
multiplicitypolytope=intoPolytope[matroidpoly];
perfmatchnumber=Position[Transpose[matroidpoly],multiplicitypolytope[[1]][[All,Ordering[multiplicitypolytope[[2]]][[1]]]]][[1,1]];
perfmatchnumber
];

reducibilityBFTQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,reducibility},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
If[Dimensions[pmatrix][[2]]==0&&Length[pmatrix]>0,
reducibility=True;
,fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]],reducibility=True;,reducibility=False;];
];
,reducibility=Null;
];
reducibility
];

reducibilityBFTedges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{pmatrix,modulispace,fullspacetranspose,modulitranspose,fullspaceshort,problemlines,reducibilityedges},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[pmatrix=!=Null&&modulispace=!=Null,
If[Dimensions[pmatrix][[2]]==0&&Length[pmatrix]>0,
reducibilityedges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
,fullspacetranspose=Transpose[pmatrix];
modulitranspose=Transpose[modulispace];
(*Now we must multiply together those columns of the Pmatrix that project to the same coordinates in the moduli space*)
fullspaceshort=Transpose[Map[Times@@fullspacetranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
problemlines=Flatten[Position[fullspaceshort,ConstantArray[0,Dimensions[fullspaceshort][[2]]]]];
reducibilityedges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]][[problemlines]];
];
,reducibilityedges=Null;
];
reducibilityedges
];

consistentEdgeRemoval[topleft_,topright_,bottomleft_,bottomright_,edgelist_,checkneeded_:False,BFTgraph_:False]:=Block[{varlist,rowstokill,pmatrix,survivingcolums,reducedpmatrix,consistentedgelist},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
rowstokill=Flatten[Position[varlist,Alternatives@@edgelist]];
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
survivingcolums=Complement[Range[Dimensions[pmatrix][[2]]],Map[#[[2]]&,Position[pmatrix[[rowstokill]],1]]];
reducedpmatrix=pmatrix[[All,survivingcolums]];
consistentedgelist=varlist[[Flatten[Position[reducedpmatrix,ConstantArray[0,Dimensions[reducedpmatrix][[2]]]]]]];
,consistentedgelist=Null;
];
consistentedgelist
];

reductionGraphBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{edges,modulispace,numpointsmodulispace,comboremove,edgereductions,comboremovnextlevel,ii},
(*First check which edges can be removed without affeting the moduli space*)
edges=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edges=!=Null,
(*We will want to find those sets of edges which, when removed, do not change the numnber of points in the moduli space*)
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,False,BFTgraph];
numpointsmodulispace=Length[Tally[Transpose[modulispace]]];
comboremove=Subsets[edges,{1}];
edgereductions=comboremove;
(*Try and remove pairs of edges. In each case, we might need to remove additional edges for a consistent edge removal (this won't affect anything)*)
comboremovnextlevel=Subsets[edges,{2}];
(*In each case check whether the number of points in the moduli space is the same*)
comboremovnextlevel=Cases[comboremovnextlevel,zz_/;Length[Tally[Transpose[modulispace[[All,survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,zz,False,BFTgraph]]]]]]==numpointsmodulispace];
(*If it's possible to remove pairs of edges without changing the moduli space, it might be possible to remove 3 edges at a time, and so on*)
If[comboremovnextlevel=!={},
For[ii=3,ii<=Length[edges]+1,ii++,
edgereductions=Join[edgereductions,comboremovnextlevel];
comboremovnextlevel=Subsets[edges,{ii}];
comboremovnextlevel=Cases[comboremovnextlevel,zz_/;Length[Tally[Transpose[modulispace[[All,survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,zz,False,BFTgraph]]]]]]==numpointsmodulispace];
(*If no cases managed to preserve the number of points in the matroid polytope, stop here. comboremove contains the last viable choices for edge removals*)
If[comboremovnextlevel==={},
Break[];
];
];
];
edgereductions=Map[consistentEdgeRemoval[topleft,topright,bottomleft,bottomright,#,False,BFTgraph]&,edgereductions];
,edgereductions=Null;(*there was some problem with the Kasteleyn*)
];
edgereductions
];

edgeOrderings[edges_,currentedge_]:=Module[{orderings,ii},
(*Start with our current edge.*)
orderings={Cases[edges,currentedge]};
(*The next edge should have the structure _[currentedge[[2]],_]. There may however be multiple alternatives of this type, and not all of them are viable edge orderings that all match up. For for each alternative, try it out by adding this alternative onto {currentedge}. Ultimately we only want to keep those alternatives that match up.*)
For[ii=1,ii<Length[edges],ii++,
(*orderings contains a list of orderings. In each case, try and tag on another edge that makes sense. If there are none that make sense, this chain of edges wasn't a viable option for edge orderings, and this thread will get killed (because the MapThread function will take an empty list, and it will Map a Join function on each element of the empty list, which returns an empty list. "Sequence" then destroys it).*)
orderings=MapThread[Sequence@@Function[{input1,input2},Map[Join[input1,{#}]&,input2]][#1,#2]&,{orderings,Map[Cases[Complement[edges,#],_[Last[#][[2]],_]]&,orderings]}];
];
orderings=Map[RotateLeft,orderings];
orderings
];

cyclicEdgeOrderings[edges_,currentedge_]:=Module[{listSubtraction,orderings,remainingedges,ii},
(*Make a function that takes a list and subtracts away the elements from a second list*)
listSubtraction=Function[{listtoremovefrom,listofremoveditems},
Block[{newlist,newremovelist,jj},
newlist=listtoremovefrom;
newremovelist=listofremoveditems;
For[jj=1,jj<=Length[listofremoveditems],jj++,
newlist=Delete[newlist,Position[newlist,newremovelist[[1]]][[1]]];
newremovelist=Delete[newremovelist,{1}]
];
newlist]
];
(*Start with our current edge.*)
orderings={{currentedge}};
(*In each ordering, we have used up a certain set of edges, so we'll also keep track of which edges remain available to us*)
remainingedges=Map[listSubtraction[edges,#]&,orderings];
(*The next edge should have the structure _[currentedge[[2]],_]. There may however be multiple alternatives of this type, and not all of them are viable edge orderings that all match up. For for each alternative, try it out by adding this alternative onto {currentedge}. Ultimately we only want to keep those alternatives that match up.*)
For[ii=1,ii<Length[edges],ii++,
orderings=MapThread[Sequence@@Function[{input1,input2},Map[Join[input1,{#}]&,input2]][#1,Cases[#2,_[Last[#1][[2]],_]]]&,{orderings,remainingedges}];
remainingedges=Map[listSubtraction[edges,#]&,orderings];
];
orderings
];

nextStepBlackToWhite[topleftbottomleft_,currentedge_,currentposition_,notallowededges_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[topleftbottomleft[[All,currentposition[[2]]]]],currentedge][[1]];
nextedges=DeleteCases[nextedges,Alternatives@@notallowededges];
nextedge=nextedges[[1]];
nextedgepos=Position[topleftbottomleft,nextedge][[1]];
{nextedge,nextedgepos}
];

nextStepWhiteToBlack[toplefttopright_,currentedge_,currentposition_,notallowededges_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[toplefttopright[[currentposition[[1]]]]],currentedge][[1]];
nextedges=DeleteCases[nextedges,Alternatives@@notallowededges];
nextedge=nextedges[[1]];
nextedgepos=Position[toplefttopright,nextedge][[1]];
{nextedge,nextedgepos}
];

nextStepBlackToWhiteInternalZigzag[topleftbottomleft_,currentedge_,currentposition_,notallowededges_,startingedge_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[topleftbottomleft[[All,currentposition[[2]]]]],currentedge][[1]];
If[nextedges[[1]]=!=startingedge,
nextedges=DeleteCases[nextedges,Alternatives@@notallowededges]
];
nextedge=nextedges[[1]];
nextedgepos=Position[topleftbottomleft,nextedge][[1]];
{nextedge,nextedgepos}
];

nextStepWhiteToBlackInternalZigzag[toplefttopright_,currentedge_,currentposition_,notallowededges_,startingedge_]:=Block[{nextedges,nextedge,nextedgepos},
nextedges=edgeOrderings[Variables[toplefttopright[[currentposition[[1]]]]],currentedge][[1]];
If[nextedges[[1]]=!=startingedge,
nextedges=DeleteCases[nextedges,Alternatives@@notallowededges]
];
nextedge=nextedges[[1]];
nextedgepos=Position[toplefttopright,nextedge][[1]];
{nextedge,nextedgepos}
];

internalZigZagNumeratorDenominator[topleft_,topright_,bottomleft_,bottomright_,startingedge_,numeratorstart_:True,alreadytakenedges_:{{},{}}]:=Block[{blacktowhitematrix,whitetoblackmatrix,kasteleyn,allnumeratoredges,alldenominatoredges,numeratoredges,denominatoredges,currentedge,currentposition},
blacktowhitematrix=Join[topleft,bottomleft];
whitetoblackmatrix=Join[topleft,topright,2];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
{allnumeratoredges,alldenominatoredges}=alreadytakenedges;
If[numeratorstart,
numeratoredges={startingedge};
allnumeratoredges=Append[allnumeratoredges,startingedge];
denominatoredges={};
,numeratoredges={};
denominatoredges={startingedge};
alldenominatoredges=Append[alldenominatoredges,startingedge];
];
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];

If[numeratorstart,
(*We will first need to go from a black vertex to a white vertex, then from black to white, and so on, until reaching the starting point*)
While[True,
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhiteInternalZigzag[blacktowhitematrix,currentedge,currentposition,alldenominatoredges,startingedge];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
alldenominatoredges=Append[alldenominatoredges,startingedge];
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlackInternalZigzag[whitetoblackmatrix,currentedge,currentposition,allnumeratoredges,startingedge];
If[currentedge===startingedge,
Break[];
];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
allnumeratoredges=Append[allnumeratoredges,startingedge];
];
,(*We will first need to go from a white vertex to a black vertex, then from white to black, and so on, until reaching the starting point*)
While[True,
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlackInternalZigzag[whitetoblackmatrix,currentedge,currentposition,allnumeratoredges,startingedge];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
allnumeratoredges=Append[allnumeratoredges,startingedge];
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhiteInternalZigzag[blacktowhitematrix,currentedge,currentposition,alldenominatoredges,startingedge];
If[currentedge===startingedge,
Break[];
];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
alldenominatoredges=Append[alldenominatoredges,startingedge];
];
];
{numeratoredges,denominatoredges}
];

allZigZagNumeratorsDenominators[topleft_,topright_,bottomleft_,bottomright_]:=Module[{kasteleyn,bottomleftvars,toprightvars,blacktowhitematrix,whitetoblackmatrix,zigZagFromExternalWhiteNode,zigZagFromExternalBlackNode,bottomleftzigzags,toprightzigzags,allnumeratoredges,alldenominatoredges,internalzigzagedges,internalzigzags,internalzigzag,allzigzags},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bottomleftvars=Variables[bottomleft];
toprightvars=Variables[topright];
blacktowhitematrix=Join[topleft,bottomleft];
whitetoblackmatrix=Join[topleft,topright,2];
(*We will begin by making a function that can give a zig-zag which starts from an external white node.*)
allnumeratoredges={};
alldenominatoredges={};
zigZagFromExternalWhiteNode=Function[{startingedge},Block[{currentedge,currentposition,denominatoredges,numeratoredges},
numeratoredges={startingedge};
allnumeratoredges=Append[allnumeratoredges,startingedge];
denominatoredges={};
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];
While[True,
(*Now run along the column to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition,alldenominatoredges];
(*This new edge should be placed in the denominator in the zig-zag expression*)
denominatoredges=Append[denominatoredges,currentedge];
alldenominatoredges=Append[alldenominatoredges,currentedge];
(*If we've reached another external node, we've finished the zig-zag*)
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
(*Now run along the row to find another edge whose first index is our currentedge's second index*)
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition,allnumeratoredges];
(*This new edge should be placed in the numerator in the zig-zag expression*)
numeratoredges=Append[numeratoredges,currentedge];
allnumeratoredges=Append[allnumeratoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
];
{numeratoredges,denominatoredges}]
];
zigZagFromExternalBlackNode=Function[{startingedge},Block[{currentedge,currentposition,denominatoredges,numeratoredges},
numeratoredges={};
denominatoredges={startingedge};
alldenominatoredges=Append[alldenominatoredges,startingedge];
currentedge=startingedge;
currentposition=Position[kasteleyn,currentedge][[1]];
While[True,
{currentedge,currentposition}=nextStepWhiteToBlack[whitetoblackmatrix,currentedge,currentposition,allnumeratoredges];
numeratoredges=Append[numeratoredges,currentedge];
allnumeratoredges=Append[allnumeratoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
{currentedge,currentposition}=nextStepBlackToWhite[blacktowhitematrix,currentedge,currentposition,alldenominatoredges];
denominatoredges=Append[denominatoredges,currentedge];
alldenominatoredges=Append[alldenominatoredges,currentedge];
If[MemberQ[Join[bottomleftvars,toprightvars],currentedge],
Break[];
];
];
{numeratoredges,denominatoredges}]
];
(*Start from each of the external nodes and make the zig-zags that begin there.*)
bottomleftzigzags=Map[zigZagFromExternalWhiteNode[#]&,bottomleftvars];
toprightzigzags=Map[zigZagFromExternalBlackNode[#]&,toprightvars];
allnumeratoredges=Sort[allnumeratoredges];
alldenominatoredges=Sort[alldenominatoredges];
(*allnumeratoredges=Sort[Flatten[Map[#[[1]]&,Join[bottomleftzigzags,toprightzigzags]]]];
alldenominatoredges=Sort[Flatten[Map[#[[2]]&,Join[bottomleftzigzags,toprightzigzags]]]];
*)(*If there are any edges that do not appear in any of the numerators, we must have a zig-zag path which is purely internal*)
(*Start from each of the edges that are missing a zig-zag, and create the internal zig-zags that run over this edge*)
internalzigzagedges=Complement[Variables[kasteleyn],allnumeratoredges];
internalzigzags={};
While[internalzigzagedges=!={},
internalzigzag=internalZigZagNumeratorDenominator[topleft,topright,bottomleft,bottomright,internalzigzagedges[[1]],True,{allnumeratoredges,alldenominatoredges}];
internalzigzags=Append[internalzigzags,internalzigzag];
allnumeratoredges=Join[allnumeratoredges,internalzigzag[[1]]];
alldenominatoredges=Join[alldenominatoredges,internalzigzag[[2]]];
internalzigzagedges=Complement[Variables[kasteleyn],allnumeratoredges];
];
(*There shouldn't be, but just in case also look at edge in the denominator in case there's some zig-zag we're missing*)
internalzigzagedges=Complement[Variables[kasteleyn],alldenominatoredges];
While[internalzigzagedges=!={},
internalzigzag=internalZigZagNumeratorDenominator[topleft,topright,bottomleft,bottomright,internalzigzagedges[[1]],False,{allnumeratoredges,alldenominatoredges}];
internalzigzags=Append[internalzigzags,internalzigzag];
allnumeratoredges=Join[allnumeratoredges,internalzigzag[[1]]];
alldenominatoredges=Join[alldenominatoredges,internalzigzag[[2]]];
internalzigzagedges=Complement[Variables[kasteleyn],alldenominatoredges];
];
(*Now all edges have appeared in the numerator of some zig-zag and the denominator of some (possibly the same) zig-zag*)
allzigzags=Join[bottomleftzigzags,toprightzigzags,internalzigzags];
(*If there are any edges that do not appear in the actual expressions for the zig-zags, it means we have a self-intersecting zig-zag*)
allzigzags
];

makeZigZags[topleft_,topright_,bottomleft_,bottomright_,invertedrule_:False]:=Block[{graphOK,allzigzags,zigzagexpressions},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
zigzagexpressions=Map[(Times@@#[[1]])/(Times@@#[[2]])&,allzigzags];
(*If we want to turn right at white nodes and left at black nodes, all the zig-zags are inverted*)
If[invertedrule,
zigzagexpressions=Map[1/#&,zigzagexpressions];
];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
zigzagexpressions=Null;
];
zigzagexpressions
];

selfIntersectingZigZagsQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{graphOK,allzigzags,selfintersectingzigzags,selfintersections},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
(*If an edge is both in the numerator and the denominator, we have a self-intersection*)
selfintersectingzigzags=Cases[allzigzags,zz_/;Length[Intersection[zz[[1]],zz[[2]]]]>0];
If[Length[selfintersectingzigzags]=!=0,
selfintersections=True;
,selfintersections=False;
];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
selfintersections=Null;
];
selfintersections
];

badDoubleCrossingZigZagPairs[topleft_,topright_,bottomleft_,bottomright_]:=Module[{graphOK,threadJointheLists,allzigzags,internalzigzags,allzigzagpairs,doubleCrossingQ,doublecrossings},
graphOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,True];
If[graphOK,
(*We begin by making all edges in the zig-zags appear in chronological order*)
threadJointheLists=Function[{numerator,denominator},
Block[{list1,list2},
If[Length[numerator]>=Length[denominator],
list1=Flatten[Transpose[{numerator,numerator}]];
list2=denominator;
,list1=Flatten[Transpose[{denominator,denominator}]];
list2=numerator;
];
(*Interweave the two lists*)
list1[[Range[2,2Length[list2],2]]]=list2;
list1=PadRight[list1,Length[numerator]+Length[denominator]];
(*If the numerator and the denominator had the same numnber of edges, we don't know which edge should come first, so we'll need to check that the index structure is all correct*)
If[Length[numerator]==Length[denominator],
If[(And@@Map[Equal@@#&,Partition[Drop[Drop[Flatten[Map[List@@#&,list1]],1],-1],2]])==False,
(*The index structure wasn't correct, and we should have started with the first edge in the denominator*)
(*Print["had to do it the opposite way!"];*)
list1=Flatten[Transpose[{numerator,numerator}]];
list2=denominator;
list1[[Range[1,2Length[list2],2]]]=list2;
list1=PadRight[list1,Length[numerator]+Length[list2]];
];
];If[(And@@Map[Equal@@#&,Partition[Drop[Drop[Flatten[Map[List@@#&,list1]],1],-1],2]])==False,Print["We somehow still messed up!"];];
list1]
];
allzigzags=allZigZagNumeratorsDenominators[topleft,topright,bottomleft,bottomright];
allzigzags=Map[threadJointheLists[#[[1]],#[[2]]]&,allzigzags];
(*Now we have the chronological list of edes in each zig-zag. We need to now look at the pairwaise intersections between them to determine whether we have "bad double crossings"*)
(*Since internal zig-zags are cyclic, we will write out two cycles of them, so that multiple intersections can be seen to occur chronologically correctly*)
internalzigzags=Cases[allzigzags,zz_/;Intersection[zz,Variables[Join[bottomleft,topright]]]==={}];
allzigzags=allzigzags/.Map[#->Join[#,#]&,internalzigzags];
allzigzagpairs=Subsets[allzigzags,{2}];
doubleCrossingQ=Function[{zigzag1,zigzag2},
Block[{intersectionvars,zig1intersectionpairs,zig2intersections,badcrossing},
intersectionvars=Alternatives@@Intersection[zigzag1,zigzag2];
(*Look at all pairs of variables in zigzag1 and see whether they appear in the same order*)
zig1intersectionpairs=Subsets[Cases[zigzag1,intersectionvars],{2}];
zig2intersections=Cases[zigzag2,intersectionvars];
badcrossing=Or@@Map[Cases[zig2intersections[[Range[Position[zig2intersections,#[[1]]][[1,1]],Length[zig2intersections]]]],#[[2]]]=!={}&,zig1intersectionpairs];
badcrossing]
];
doublecrossings=Cases[allzigzagpairs,zz_/;doubleCrossingQ@@zz];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
doublecrossings=Null;
];
doublecrossings
];

badDoubleCrossingZigZagQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{baddoublecrossings,return},
baddoublecrossings=badDoubleCrossingZigZagPairs[topleft,topright,bottomleft,bottomright];
If[baddoublecrossings=!=Null,
return=baddoublecrossings=!={};
,return=Null;];
return
];

zigZagsAsPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,invertedrule_:False]:=Block[{zigzags,perfmatchings,perfmatchzigzags,ii,jj,perfmatchratio,positions,tobereplacedwith,replacementrule},
zigzags=makeZigZags[topleft,topright,bottomleft,bottomright,invertedrule];
If[zigzags=!=Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright,False,True];
perfmatchzigzags=Table[{},{iii,Length[zigzags]}];
For[ii=1,ii<=Length[perfmatchings],ii++,
For[jj=1,jj<=Length[perfmatchings],jj++,
perfmatchratio=perfmatchings[[ii]]/perfmatchings[[jj]];
positions=Flatten[Position[Map[#===perfmatchratio&,zigzags],True]];
tobereplacedwith=Map[Append[#,{perfmatchings[[ii]],perfmatchings[[jj]]}]&,perfmatchzigzags[[positions]]];
replacementrule=MapThread[Rule,{positions,tobereplacedwith}];
perfmatchzigzags=ReplacePart[perfmatchzigzags,replacementrule];
];
];
,perfmatchzigzags=Null;
];
perfmatchzigzags
];

makeLoopVariablesBasis[topleft_,topright_,bottomleft_,bottomright_,standardfacevariables_:False]:=Module[{kasteleyn,alledges,externaledges,extnodenumbers,externaledgestonodenumbers,bpaths,adjacencymat,graph,bigkasteleyn,nameUndirectedEdges,bpathvectors,directedgraph,nameDirectedEdges,edgelist,internalpaths,internalpathvectors,facenames,facevariables,facevariablevectors,internalpos,internalfacevariables,internalfacevariablevectors,externalfacevariables,externalfacevariablevectors,accountedforvectors,newpathvectors,additionalpathvectors,tosolvefor,coef,coeflist,additionalpaths,loopvariablebasis},
(*We'll begin by making all possible paths between boundaries. Some of these will correspond to external faces (or combinations thereof), but some will be paths stretching between different boundaries*)
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
alledges=Variables[kasteleyn];
(*We need to extract the external edges*)
externaledges=Variables[Join[bottomleft,topright]];
(*extnodenumbers=Flatten[Map[Cases[#[[1]],Alternatives@@Join[Range[Length[bottomleft]]+Length[topleft],Range[Dimensions[topright][[2]]]+Total[Dimensions[topleft]]+Length[bottomleft]]]&,Map[#[[{1,2}]]+{0,Length[kasteleyn]}&,Map[Position[kasteleyn,#]&,externaledges],{2}]]];*)
extnodenumbers=Flatten[Map[externalEdgesNodeNumbers[topleft,topright,bottomleft,bottomright,{#}]&,externaledges]];
externaledgestonodenumbers=MapThread[Rule,{externaledges,extnodenumbers}];
bpaths=Subsets[externaledges,{2}];(*For now bpaths only contain the external edges. We'll now look for the shortest path between these edges, to complete the paths between boundaries*)
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];
bpaths=Map[Table[UndirectedEdge[#[[iii]],#[[iii+1]]],{iii,Length[#]-1}]&,Map[FindShortestPath[graph,Sequence@@#]&,bpaths/.externaledgestonodenumbers]];
(*Now each boundary path is expressed as a list of directed edges that go from one boundary to the next. We need to turn these directed edges into a product of edges*)
bigkasteleyn=Join[kasteleyn,Transpose[kasteleyn]];
nameUndirectedEdges=Function[{undirectededge},
Block[{edgename,edgeweight},
edgename=(Intersection@@Map[Variables[bigkasteleyn[[#]]]&,List@@undirectededge])[[1]];
If[undirectededge[[1]]<undirectededge[[2]],
edgeweight=edgename;
,edgeweight=1/edgename;
];
edgeweight]
];
bpaths=Map[Times@@#&,Map[nameUndirectedEdges,bpaths,{2}]];
(*Now we have the paths running between boundaries, expressed as products of edge variables*)
bpathvectors=Map[Table[D[#,alledges[[iii]]],{iii,Length[alledges]}]/.Map[#->1&,alledges]&,bpaths];
(*We shall now make all internal paths. These contain internal faces, non-trivial paths around higher-genus, and products of external faces around each boundary*)
(*We start from a direct graph, as this will allow us to understand the direction of our internal loops*)
directedgraph=AdjacencyGraph[UpperTriangularize[adjacencymat]];
nameDirectedEdges=Function[{directededge},
Block[{edgename},
edgename=(Intersection@@Map[Variables[bigkasteleyn[[#]]]&,List@@directededge])[[1]];
bigkasteleyn=bigkasteleyn/.{edgename->0};
edgename]
];
edgelist=Map[nameDirectedEdges,EdgeList[directedgraph]];(*watch out! I have now changed bigkasteleyn! If you need it again, you'll need to reset it*)
internalpaths=Map[Times@@Power[edgelist,#]&,Normal[EdgeCycleMatrix[directedgraph]]];
internalpathvectors=Map[Table[D[#,alledges[[iii]]],{iii,Length[alledges]}]/.Map[#->1&,alledges]&,internalpaths];
If[standardfacevariables,
(*The only paths that we still need to make are the face variables. Some of these are included in internalpathvectors, but we don't know which so we'll make all of them*)
facenames=allFaceLabels[topleft,topright,bottomleft,bottomright];
facevariables=Map[(Times@@Cases[alledges,_[_,#]])/(Times@@Cases[alledges,_[#,_]])&,facenames];
facevariablevectors=Map[Table[D[#,alledges[[iii]]],{iii,Length[alledges]}]/.Map[#->1&,alledges]&,facevariables];
internalpos=Flatten[Position[facenames,Alternatives@@internalFaceLabels[topleft,topright,bottomleft,bottomright]]];
internalfacevariables=facevariables[[internalpos]];
internalfacevariablevectors=facevariablevectors[[internalpos]];
externalfacevariables=Complement[facevariables,internalfacevariables];
externalfacevariablevectors=Complement[facevariablevectors,internalfacevariablevectors];
(*Since the face variables are not all independent, we'll remove one*)
If[Length[internalfacevariables]==Length[facevariables],
internalfacevariables=internalfacevariables[[Range[Length[internalfacevariables]-1]]];
internalfacevariablevectors=internalfacevariablevectors[[Range[Length[internalfacevariablevectors]-1]]];
,externalfacevariables=externalfacevariables[[Range[Length[externalfacevariables]-1]]];
externalfacevariablevectors=externalfacevariablevectors[[Range[Length[externalfacevariablevectors]-1]]];
];
(*We'll now need to see which of all our paths are independent and forms a basis*)
(*We need to give priority to facevariables, and then form the remaining paths with internalpaths and bpaths*)
(*We will want to keep the internal faces separate as they can be gauged under gauging 1*)
accountedforvectors=Join[internalfacevariablevectors,externalfacevariablevectors];(*the faces aren't all independent*)
newpathvectors=Join[internalpathvectors,bpathvectors];
,(*We need to give priority to internalpaths, as they can be gauged under gauging 2. We'll then form the remaining paths with facevariables and bpaths*)
accountedforvectors=internalpathvectors;
newpathvectors=bpathvectors;
];
additionalpathvectors={};
tosolvefor=Total[Table[coef[iii]accountedforvectors[[iii]],{iii,Length[accountedforvectors]}]];
coeflist=Table[coef[iii],{iii,Length[accountedforvectors]}];
newpathvectors=Cases[newpathvectors,zz_/;Length[Solve[tosolvefor==zz,coeflist]]==0];
While[newpathvectors=!={},
additionalpathvectors=Append[additionalpathvectors,newpathvectors[[1]]];
accountedforvectors=Prepend[accountedforvectors,newpathvectors[[1]]];
tosolvefor=tosolvefor+accountedforvectors[[1]]coef[Length[accountedforvectors]];
coeflist=Append[coeflist,coef[Length[accountedforvectors]]];
newpathvectors=Cases[newpathvectors,zz_/;Length[Solve[tosolvefor==zz,coeflist]]==0];
];
additionalpaths=Map[Times@@Power[alledges,#]&,additionalpathvectors];
If[standardfacevariables,
loopvariablebasis=Join[{internalfacevariables},{Join[externalfacevariables,additionalpaths]}];
,loopvariablebasis=Join[{internalpaths},{additionalpaths}];
];
loopvariablebasis
];

moduliLoopVariablesBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,referencematching_:Null,loopvariablebasis_:Null]/;(gauging===1||gauging===2):=Block[{perfmatchings,referenceperfmatch,basispaths,basis,kasteleyn,allvariables,perfmatchingvectors,basisvectors,tosolvefor,coef,coeflist,perfmatchingsasloops,masterspace,modulispace,internalfacenames,internalfacevariables,internalfacevariablevectors,internalfacesasbasispaths,vectorMod},
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
If[referencematching===Null,
referenceperfmatch=perfmatchings[[1]];
,referenceperfmatch=referencematching;
];
If[loopvariablebasis===Null,
(*make my own basis*)
If[gauging==2,
basispaths=makeLoopVariablesBasis[topleft,topright,bottomleft,bottomright];
,basispaths=makeLoopVariablesBasis[topleft,topright,bottomleft,bottomright,True];
];
,basispaths=loopvariablebasis;
];
(*The first part contains what we'll gauge away (e.g. the internal loops), the second contains remaining paths (e.g. external faces, or those strecthing between different boundaries)*)
basis=Flatten[basispaths];
(*We'll now express each perfect matching as a vector describing which edges are present (1: in numerator; -1: in denominator; 0: absent)*)
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
allvariables=Variables[kasteleyn];
perfmatchingvectors=Map[Table[D[#,allvariables[[iii]]],{iii,Length[allvariables]}]/.Map[#->1&,allvariables]&,perfmatchings/referenceperfmatch];
(*We'll also express the path basis in this vectorial way*)
basisvectors=Map[Table[D[#,allvariables[[iii]]],{iii,Length[allvariables]}]/.Map[#->1&,allvariables]&,basis];
(*We can now solve for which basis vectors are required to form a given expression*)
tosolvefor=Total[Table[coef[iii]basisvectors[[iii]],{iii,Length[basisvectors]}]];coeflist=Table[coef[iii],{iii,Length[basisvectors]}];
perfmatchingsasloops=Map[#[[2]]&,Map[Solve[tosolvefor==#,coeflist][[1]]&,perfmatchingvectors],{2}];
(*We now have the expression of each perfect matching in terms of the loop basis*)
masterspace=Transpose[perfmatchingsasloops];
(*We need to gauge away all internal faces, and if we use gauging 2 also all internal loops. This corresponds to the first rows of the masterspace*)
If[loopvariablebasis===Null,
(*if I made my own basis, I arranged it such that the first entry is what we'll be gauging away. Otherwise, we'll need to find what to gauge away by hand*)
modulispace=masterspace[[Range[Length[basispaths[[1]]]+1,Length[basis]]]];
,(*We need to gauge away internal faces only. We'll find out how to express internal faces in terms of basispaths, and then mod out by these expressions*)
internalfacenames=internalFaceLabels[topleft,topright,bottomleft,bottomright];
internalfacevariables=Map[(Times@@Cases[allvariables,_[_,#]])/(Times@@Cases[allvariables,_[#,_]])&,internalfacenames];
internalfacevariablevectors=Map[Table[D[#,allvariables[[iii]]],{iii,Length[allvariables]}]/.Map[#->1&,allvariables]&,internalfacevariables];
tosolvefor=Total[Table[coef[iii]basisvectors[[iii]],{iii,Length[basisvectors]}]];
coeflist=Table[coef[iii],{iii,Length[basisvectors]}];
(*We'll now express the internal faces as a combination of basis paths*)
internalfacesasbasispaths=Map[#[[2]]&,Map[Solve[tosolvefor==#,coeflist][[1]]&,internalfacevariablevectors],{2}];
(*We'll need to mod out by these vectors, as they represent internal faces*)
vectorMod=Function[{vector,modoutbyvectors},
Total[Map[Projection[vector,#]&,NullSpace[modoutbyvectors]]]
];
modulispace=Transpose[Map[vectorMod[#,internalfacesasbasispaths]&,perfmatchingsasloops]];
];
If[modulispace==={},
modulispace={ConstantArray[0,Dimensions[masterspace][[2]]]};
];
,
If[loopvariablebasis===Null,
(*make my own basis*)
If[gauging==2,
basispaths=makeLoopVariablesBasis[topleft,topright,bottomleft,bottomright];
,basispaths=makeLoopVariablesBasis[topleft,topright,bottomleft,bottomright,True];
];
,basispaths=loopvariablebasis;
];
basis=Flatten[basispaths];
masterspace=Table[{},{iii,Length[basis]}];
modulispace=Table[{},{iii,Length[basispaths[[2]]]}];
];
,Print["The graph must be of BFT type for this function to work: edges must be of the form _[_Integer,_Integer] and be labeled according the numbering of faces."];
basis=Null;
masterspace=Null;
modulispace=Null;
];
{masterspace,modulispace,basis}
];


(*Functions useful for scattering amplitudes*)


planarityQ[topleft_,topright_,bottomleft_,bottomright_]:=
planarityQ[topleft,topright,bottomleft,bottomright]=Block[{kasteleyn,oneskasteleyn,adjacencymat,graph,planar,externals,extnum,allperms,numberofperms,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
(*If the graph can be embedded on genus zero, try and see if we can do so with only one boundary*)
planar=False;(*assume the graph is non-planar until proven otherwise*)
If[PlanarGraphQ[graph],
externals=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];(*These are the node numbers corresponding to external nodes*)
extnum=Length[externals];
If[extnum>0,
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
allperms=Permutations[Range[extnum-1]];
numberofperms=Length[allperms];
permutations=Map[Append[#,extnum]&,allperms[[DeleteDuplicates[MapThread[Sort[{#1,#2}][[1]]&,{Range[numberofperms],Ordering[Map[Reverse[#]&,allperms]]}]]]]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
If[permutations[[1]]==={1,2},
externaladjacencyseed={{0,1},{1,0}};
,If[permutations[[1]]==={1},
externaladjacencyseed={1};
,externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
];
];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],
planar=True;
Break[];
];
];
,(*the graph has no external nodes but can be embedded on the disk nonetheless*)
planar=True;
];
];
planar
];

externalEdgeOrderingDefault[topleft_,topright_,bottomleft_,bottomright_]:=Block[{bigkasteleyn,ordering},
bigkasteleyn=Join[joinupKasteleyn[topleft,topright,bottomleft,bottomright],Transpose[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]];
ordering=externalNodeOrderingDefault[topleft,topright,bottomleft,bottomright];
ordering=Map[#[[1,1]]->#[[2]]&,DeleteCases[MapThread[Rule,{Map[Variables[bigkasteleyn[[#]]]&,ordering],Range[Length[ordering]]}],{}->___]];
ordering
];

externalNodeOrderingDefault[topleft_,topright_,bottomleft_,bottomright_]:=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];

findSourceEdges[topright_,bottomleft_,referenceperfmatch_]:=Block[{referencevars,sourceedges},
referencevars=Variables[referenceperfmatch];
(*Sources are those variables in the bottomleft that are not in referenceperfmatch, and those in topright which are*)
sourceedges=Union[Complement[DeleteCases[Flatten[bottomleft],0],referencevars],Intersection[DeleteCases[Flatten[topright],0],referencevars]];
sourceedges
];

findSinkEdges[topright_,bottomleft_,referenceperfmatch_]:=Block[{perfmatchvars,sinkedges},
perfmatchvars=Variables[referenceperfmatch];
(*Sinks are those variables in the bottomleft that are in referenceperfmatch, and those in topright which are not*)
sinkedges=Union[Complement[DeleteCases[Flatten[topright],0],perfmatchvars],Intersection[DeleteCases[Flatten[bottomleft],0],perfmatchvars]];
sinkedges
];

findSourceNodes[topleft_,topright_,bottomleft_,bottomright_,referenceperfmatch_]:=Block[{referencevars,sourcenodes},
referencevars=Variables[referenceperfmatch];
(*Sources are those nodes in the bottomleft that do not have variables in referenceperfmatch, and those in topright which do*)
sourcenodes=Union[Flatten[Position[Transpose[topright],{___,Alternatives@@referencevars,___}]]+Total[Dimensions[topleft]]+Length[bottomleft],Length[topleft]+Complement[Range[Length[bottomleft]],Flatten[Position[bottomleft,{___,Alternatives@@referencevars,___}]]]];
sourcenodes
];

findSinkNodes[topleft_,topright_,bottomleft_,bottomright_,referenceperfmatch_]:=Block[{referencevars,sinknodes},
referencevars=Variables[referenceperfmatch];
(*Sinks are those nodes in the bottomleft that have variables in referenceperfmatch, and those in topright which are do not*)
sinknodes=Union[Complement[Range[Dimensions[topright][[2]]],Flatten[Position[Transpose[topright],{___,Alternatives@@referencevars,___}]]]+Total[Dimensions[topleft]]+Length[bottomleft],Length[topleft]+Flatten[Position[bottomleft,{___,Alternatives@@referencevars,___}]]];
sinknodes
];

externalEdgesNodeNumbers[topleft_,topright_,bottomleft_,bottomright_,externaledgelist_]:=Union[Map[#[[1]]&,Position[bottomleft,Alternatives@@externaledgelist]+Length[topleft]],Map[#[[2]]&,Position[topright,Alternatives@@externaledgelist]+Total[Dimensions[topleft]]+Length[bottomleft]]];

traditionalConnectivityMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=traditionalConnectivityMatrix[topleft,topright,bottomleft,bottomright,referencematching]=traditionalConnectivityMatrix[topleft,topright,bottomleft,bottomright]=Block[{perfmatchings,referenceperfmatch,kasteleyn,perfmatchvars,kastnopm,kastinvertedpm,bigmatrix,size,connectivitymat},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
perfmatchvars=Variables[referenceperfmatch];
(*We need to first form a large matrix based on the Kasteleyn, and then take its inverse*)
kastnopm=-(kasteleyn/.Map[#->0&,perfmatchvars]);
kastinvertedpm=-Transpose[kasteleyn/.Join[Map[#->1/#&,perfmatchvars],Map[#->0&,Complement[Variables[kasteleyn],perfmatchvars]]]];
bigmatrix=Join[Join[IdentityMatrix[Length[kasteleyn]],kastinvertedpm],Join[kastnopm,IdentityMatrix[Dimensions[kasteleyn][[2]]]],2];
connectivitymat=Inverse[bigmatrix];
,Print["This graph has no perfect matchings"];
size=Total[Dimensions[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]];
connectivitymat=IdentityMatrix[size];
];
connectivitymat
];

connectivityMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=connectivityMatrix[topleft,topright,bottomleft,bottomright,referencematching]=connectivityMatrix[topleft,topright,bottomleft,bottomright]=Module[{perfmatchings,referenceperfmatch,kasteleyn,bigmatrix,adjacencymat,graph,connectivitymat,turnIntoContributionNoLoops,cycles,loopnodes,extraloopnodes,jj,toadd,duplnode,loopcontributions,cyclenodes,turnIntoContribution,size},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bigmatrix=getOrientedAdjacencyMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch,True];adjacencymat=bigmatrix/.Map[#->1&,Variables[kasteleyn]];
graph=AdjacencyGraph[adjacencymat];
(*We'll now find all paths between all nodes, expressed a lists of nodes traversed between the two endpoints*)
connectivitymat=Table[FindPath[graph,iii,jjj,Infinity,All],{iii,Total[Dimensions[kasteleyn]]},{jjj,Total[Dimensions[kasteleyn]]}];
(*FindPath misses the diagonal, i.e. from a node to itself, so we'll put that in by hand*)
connectivitymat=MapThread[Join,{connectivitymat,Map[{{#}}&,DiagonalMatrix[Range[Total[Dimensions[kasteleyn]]]],{2}]/.{{{0}}->{}}},2];
(*this function translates a sequence of nodes to an expression in terms of edge variables, neglecting the loop contributions in the denominator*)
turnIntoContributionNoLoops=Function[{pathnodes},
(Times@@Map[Power[bigmatrix[[Sequence@@#]],Signature[#]]&,Table[pathnodes[[{iii,iii+1}]],{iii,Length[pathnodes]-1}]])
];
(*for the final contribution to each element in the connectivity matrix, we'll need the contributions from loops*)
cycles=FindCycle[graph,Infinity,All]/.{DirectedEdge->List};(*these are the loops*)
(*we'll now turn each cycle into an expression similar to the output of FindPath*)
loopnodes=MapThread[Prepend,{Map[#[[2]]&,cycles,{2}],Map[#[[1,1]]&,cycles]}];
(*we now have the fundamental loops in the graph. We still need to add all combinations of independent loops (i.e. those loops which do not share nodes)*)
extraloopnodes={};
For[jj=2,jj<=Length[loopnodes],jj++,
toadd=Cases[Subsets[loopnodes,{jj}],Except[{___,{___,duplnode_,___},___,{___,duplnode_,___},___}]];
If[toadd==={},
Break[];
];
extraloopnodes=Join[extraloopnodes,toadd];
];
loopnodes=Join[Transpose[{loopnodes}],extraloopnodes];
(*loopcontributions contains the full list of loops, with their correct sign*)
loopcontributions=Map[Power[-1,Length[#]-1](Times@@#)&,Map[turnIntoContributionNoLoops,loopnodes,{2}]];
(*we want to know which nodes are occupied by each loopcontribution, in order to have the correct numerators. cyclenodes has the node numbers*)
cyclenodes=Map[Union@@#&,loopnodes];
turnIntoContribution=Function[{pathnodes},
Module[{totalcontrib},
totalcontrib=turnIntoContributionNoLoops[pathnodes];
totalcontrib=totalcontrib/(1-Expand[Total[loopcontributions]]);
totalcontrib=totalcontrib(1-Expand[Total[loopcontributions[[Flatten[Position[Map[Length[Intersection[#,pathnodes]]>0&,cyclenodes],False]]]]]]);
totalcontrib
]
];
connectivitymat=Map[Total,Map[turnIntoContribution,connectivitymat,{3}],{2}];
,Print["This graph has no perfect matchings"];
size=Total[Dimensions[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]];
connectivitymat=IdentityMatrix[size];
];
connectivitymat
];

traditionalPathMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=
traditionalPathMatrix[topleft,topright,bottomleft,bottomright,referencematching]=traditionalPathMatrix[topleft,topright,bottomleft,bottomright]=Block[{perfmatchings,referenceperfmatch,bigpathmatrix,externalrows,externalcolumns,finalpathmatrix},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
bigpathmatrix=connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
(*bigpathmatrix contains the connectivity between ALL pairs of nodes. We need to select those entries corresponding to sources goign to external nodes.*)
externalrows=findSourceNodes[topleft,topright,bottomleft,bottomright,referenceperfmatch];
externalcolumns=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];
finalpathmatrix=Expand[Simplify[bigpathmatrix[[externalrows,externalcolumns]]]];
(*The determinant of bigpathmatrix gives the loop factor in the paths between external nodes.*)
,Print["This graph has no perfect matchings"];
finalpathmatrix=Null;
];
finalpathmatrix
];

pathMatrix[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=
pathMatrix[topleft,topright,bottomleft,bottomright,referencematching]=pathMatrix[topleft,topright,bottomleft,bottomright]=Module[{perfmatchings,referenceperfmatch,kasteleyn,bigmatrix,adjacencymat,graph,sources,allexternalnodes,finalpathmatrix,turnIntoContributionNoLoops,cycles,loopnodes,extraloopnodes,jj,toadd,duplnode,loopcontributions,cyclenodes,turnIntoContribution},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bigmatrix=getOrientedAdjacencyMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch,True];adjacencymat=bigmatrix/.Map[#->1&,Variables[kasteleyn]];
graph=AdjacencyGraph[adjacencymat];
sources=findSourceNodes[topleft,topright,bottomleft,bottomright,referenceperfmatch];
allexternalnodes=externalNodeOrderingDefault[topleft,topright,bottomleft,bottomright];
(*We'll now find all paths between source nodes and external nodes, expressed a lists of nodes traversed between the two endpoints*)
finalpathmatrix=Table[FindPath[graph,sources[[iii]],allexternalnodes[[jjj]],Infinity,All],{iii,Length[sources]},{jjj,Length[allexternalnodes]}];
If[finalpathmatrix=!={},
(*FindPath misses the diagonal, i.e. from a node to itself, so we'll put that in by hand*)
finalpathmatrix[[All,Flatten[Position[allexternalnodes,Alternatives@@sources]]]]=Map[{{#}}&,DiagonalMatrix[sources],{2}]/.{{{0}}->{}};
(*this function translates a sequence of nodes to an expression in terms of edge variables, neglecting the loop contributions in the denominator*)
turnIntoContributionNoLoops=Function[{pathnodes},
(Times@@Map[Power[bigmatrix[[Sequence@@#]],Signature[#]]&,Table[pathnodes[[{iii,iii+1}]],{iii,Length[pathnodes]-1}]])
];
(*for the final contribution to each element in the connectivity matrix, we'll need the contributions from loops*)
cycles=FindCycle[graph,Infinity,All]/.{DirectedEdge->List};(*these are the loops*)
(*we'll now turn each cycle into an expression similar to the output of FindPath*)
loopnodes=MapThread[Prepend,{Map[#[[2]]&,cycles,{2}],Map[#[[1,1]]&,cycles]}];
(*we now have the fundamental loops in the graph. We still need to add all combinations of independent loops (i.e. those loops which do not share nodes)*)
extraloopnodes={};
For[jj=2,jj<=Length[loopnodes],jj++,
toadd=Cases[Subsets[loopnodes,{jj}],Except[{___,{___,duplnode_,___},___,{___,duplnode_,___},___}]];
If[toadd==={},
Break[];
];
extraloopnodes=Join[extraloopnodes,toadd];
];
loopnodes=Join[Transpose[{loopnodes}],extraloopnodes];
(*loopcontributions contains the full list of loops, with their correct sign*)
loopcontributions=Map[Power[-1,Length[#]-1](Times@@#)&,Map[turnIntoContributionNoLoops,loopnodes,{2}]];
(*we want to know which nodes are occupied by each loopcontribution, in order to have the correct numerators. cyclenodes has the node numbers*)
cyclenodes=Map[Union@@#&,loopnodes];
turnIntoContribution=Function[{pathnodes},
Module[{totalcontrib},
totalcontrib=turnIntoContributionNoLoops[pathnodes];
totalcontrib=totalcontrib/(1-Expand[Total[loopcontributions]]);
totalcontrib=totalcontrib(1-Expand[Total[loopcontributions[[Flatten[Position[Map[Length[Intersection[#,pathnodes]]>0&,cyclenodes],False]]]]]]);
totalcontrib
]
];
finalpathmatrix=Map[Total,Map[turnIntoContribution,finalpathmatrix,{3}],{2}];
];
,Print["This graph has no perfect matchings"];
finalpathmatrix=Null;
];
finalpathmatrix
];

getLoopDenominator[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,withsigns_:False]:=
(*getLoopDenominator[topleft,topright,bottomleft,bottomright,referencematching]=getLoopDenominator[topleft,topright,bottomleft,bottomright]=*)Module[{perfmatchings,referenceperfmatch,kasteleyn,bigmatrix,adjacencymat,graph,turnIntoContributionNoLoops,cycles,loopnodes,extraloopnodes,jj,toadd,duplnode,loopcontributions,loopdenominator},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bigmatrix=getOrientedAdjacencyMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch,True];adjacencymat=bigmatrix/.Map[#->1&,Variables[kasteleyn]];
graph=AdjacencyGraph[adjacencymat];
(*this function translates a sequence of nodes to an expression in terms of edge variables, neglecting the loop contributions in the denominator*)
turnIntoContributionNoLoops=Function[{pathnodes},
(Times@@Map[Power[bigmatrix[[Sequence@@#]],Signature[#]]&,Table[pathnodes[[{iii,iii+1}]],{iii,Length[pathnodes]-1}]])
];
(*for the final contribution to each element in the connectivity matrix, we'll need the contributions from loops*)
cycles=FindCycle[graph,Infinity,All]/.{DirectedEdge->List};(*these are the loops*)
(*we'll now turn each cycle into an expression similar to the output of FindPath*)
loopnodes=MapThread[Prepend,{Map[#[[2]]&,cycles,{2}],Map[#[[1,1]]&,cycles]}];
(*we now have the fundamental loops in the graph. We still need to add all combinations of independent loops (i.e. those loops which do not share nodes)*)
extraloopnodes={};
For[jj=2,jj<=Length[loopnodes],jj++,
toadd=Cases[Subsets[loopnodes,{jj}],Except[{___,{___,duplnode_,___},___,{___,duplnode_,___},___}]];
If[toadd==={},
Break[];
];
extraloopnodes=Join[extraloopnodes,toadd];
];
loopnodes=Join[Transpose[{loopnodes}],extraloopnodes];
(*loopcontributions contains the full list of loops, with their correct sign*)
loopcontributions=Map[Power[-1,Length[#]-1](Times@@#)&,Map[turnIntoContributionNoLoops,loopnodes,{2}]];
If[withsigns===False,
loopdenominator=(1-Expand[Total[loopcontributions]]);
,loopdenominator=(1+Expand[Total[loopcontributions]]);
];
,Print["This graph has no perfect matchings"];
loopdenominator=Null;
];
loopdenominator
];

minorsAsPerfectMatchings[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null]:=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright]=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright,referencematching]=Block[{perfmatchings,referenceperfmatch,pathmat,minors,loopdenominator,truemapminortoperfmatch},
(*If we haven't selected a specific perfect matching, choose one with lowest possible multiplicity*)
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
If[pathmat==={},(*this happens for cases when we have no external nodes*)
truemapminortoperfmatch={};
,minors=Minors[pathmat,Length[pathmat]][[1]];
loopdenominator=Expand[referenceperfmatch getLoopDenominator[topleft,topright,bottomleft,bottomright,referenceperfmatch]];(*loopdenominator=Expand[referenceperfmatch/Expand[Simplify[Det[connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]]]]];*)
truemapminortoperfmatch=Expand[Simplify[minors loopdenominator]];
];
,truemapminortoperfmatch=Null;
];
truemapminortoperfmatch
];

dimensionGrassmannian[topleft_,topright_,bottomleft_,bottomright_]:=dimensionGrassmannian[topleft,topright,bottomleft,bottomright]=Block[{minorexpressions,minorvars,tangentspacedim},
minorexpressions=minorsAsPerfectMatchings[topleft,topright,bottomleft,bottomright];
If[minorexpressions===Null,
tangentspacedim=-1;
,If[minorexpressions==={},(*this happens when we don't have any external nodes, for example*)
tangentspacedim=0;
,minorvars=Variables[minorexpressions];
(*When computing the tangent space we need to subtract 1, because Plucker coordinates are projective variables*)
tangentspacedim=MatrixRank[Table[D[minorexpressions[[iii]],minorvars[[jjj]]],{iii,Length[minorexpressions]},{jjj,Length[minorvars]}]]-1;
];
];
tangentspacedim
];

reducibilityQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{edgesnaivereducibility,reducibility,pmatrix,numsources,numexternalnodes,maxpossibledimension,dimensionP,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibility=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibility=False;
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibility=True;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright];
If[Dimensions[pmatrix][[2]]==0&&Length[pmatrix]>0,
reducibility=True;
,numsources=Length[findSourceNodes[topleft,topright,bottomleft,bottomright,perfectMatchings[topleft,topright,bottomleft,bottomright][[1]]]];
numexternalnodes=Length[bottomleft]+Length[Transpose[topright]];
maxpossibledimension=numsources(numexternalnodes-numsources);
dimensionP=polytopeDim[pmatrix];
If[dimensionP>maxpossibledimension,
reducibility=True;
,dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
If[dimensionP>dimgrassmannian,
(*if the dimension of the Grassmannian is less than that from a naive counting of edges and perfect matchings, it is necessarily possible to remove edges without affecting the Grassmannian*)
reducibility=True;
,reducibility=False;
(*assume the graph is not reducible until you find an edge which, when removed, does not reduce the dimension*)
For[ii=1,ii<=Length[edgesnaivereducibility],ii++,
dimafteredgeremoval=dimensionGrassmannian[topleft/.{edgesnaivereducibility[[ii]]->0},topright/.{edgesnaivereducibility[[ii]]->0},bottomleft/.{edgesnaivereducibility[[ii]]->0},bottomright];
If[dimafteredgeremoval==dimgrassmannian,
(*we have found an edge which may be removed without decreasing the dimension of the Grassmannian!*)
reducibility=True;
Break[]
];
];
];
];
];
];
];
];
reducibility
];

reducibilityEdges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{edgesnaivereducibility,reducibilityedgelist,dimgrassmannian,dimafteredgeremoval,ii},(*First need to find out which columns are the same point in the moduli space*)
edgesnaivereducibility=reducibilityBFTedges[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
If[edgesnaivereducibility===Null,
reducibilityedgelist=Null;(*there was some problem with the Kasteleyn*)
,If[edgesnaivereducibility==={},
(*the removal of any edge will necessarily change the matroid polytope, and so the graph cannot be reducible*)
reducibilityedgelist={};
,If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*if the graph is planar, if we may remove edges without changing the matroid polytope it means that the graph is reducible. Equally, this is the definition for a BFT graph to be reducible*)
reducibilityedgelist=edgesnaivereducibility;
,(*if we have a non-planar scattering graph, we need to do things carefully.*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
(*Just select those edgs which, when removed, do not decrease the dimension of the Grassmannian*)
reducibilityedgelist=Cases[edgesnaivereducibility,zz_/;dimensionGrassmannian[topleft/.{zz->0},topright/.{zz->0},bottomleft/.{zz->0},bottomright]==dimgrassmannian];
];
];
];
reducibilityedgelist
];

reductionGraph[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{naivereductionedges,reductionedges,dimgrassmannian},
naivereductionedges=reductionGraphBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
If[naivereductionedges=!=Null,
If[naivereductionedges==={},
reductionedges={};
,(*If the graph is planar or is a BFT, the BFT definition of reductions is valid*)
If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
reductionedges=naivereductionedges;
,(*we have a non-planar scattering graph, and must be more careful*)
dimgrassmannian=dimensionGrassmannian[topleft,topright,bottomleft,bottomright];
(*We only want those sets of edges which, when removed, do not reduce the dimension of the Grassmannian*)
reductionedges=Cases[naivereductionedges,zz_/;dimensionGrassmannian[topleft/.Map[#->0&,zz],topright/.Map[#->0&,zz],bottomleft/.Map[#->0&,zz],bottomright]==dimgrassmannian];
];
];
,reductionedges=Null;
];
reductionedges
];

nonPluckerPolesQ[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False]:=Block[{fullreducibility,nonstandardpoles},
(*Can only tell if the graph is reduced*)
fullreducibility=reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded];
If[fullreducibility=!=Null,
If[reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded]==False,
(*If the graph is reduced but the naive reducibility tells you that it's possible to remove edges without killing any Plucker coordinates, it means that some poles are nonstandard poles, i.e. that they aren't simply products of Plucker coordinates*)
nonstandardpoles=reducibilityBFTQ[topleft,topright,bottomleft,bottomright,checkneeded];
,Print["Need to start with a reduced graph."];
nonstandardpoles=Null;
];
,nonstandardpoles=Null;
];
nonstandardpoles
];

removableEdges[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{startingpointbad,removables,varlist,varstotryout,quickReducibility,fullpmatrix,dimpmatrix,fullmodulispace,survivingperfmatchings,survivingrows,reducibilities},
startingpointbad=False;
If[checkneeded,
startingpointbad=reducibilityQ[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
];
If[startingpointbad=!=Null,
If[startingpointbad,
Print["The starting graph is reducible. Reduce it first, using reductionGraph."];
removables=Null;
,(*We need to try to remove in turn each of the edges of the graph, and check whether the resulting graph is reducible*)
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
varstotryout=DeleteDuplicates[Map[consistentEdgeRemoval[topleft,topright,bottomleft,bottomright,{#},False,BFTgraph]&,varlist]];
(*If we have a BFT graph, or a planar scattering graph, or a nonplanar scattering graph with no non-standard poles, we may use the moduli space / matroid polytope to determine reducibility.*)
If[BFTgraph||planarityQ[topleft,topright,bottomleft,bottomright],
(*Create a function that can give the reducibility of a given P-matrix with its corresponding moduli space / matroid polytope*)
quickReducibility=Function[{pmatrix,modulispace},
Block[{pmatrixtranspose,modulitranspose,pmatrixshort,reducib},
If[pmatrix==={},
reducib=True;
,pmatrixtranspose=Transpose[pmatrix];
If[modulispace==={},modulitranspose=Table[{0},Length[pmatrixtranspose]];,modulitranspose=Transpose[modulispace];];
pmatrixshort=Transpose[Map[Times@@pmatrixtranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[pmatrixshort,ConstantArray[0,Dimensions[pmatrixshort][[2]]]],reducib=True;,reducib=False;];];
reducib]];
(*Now make the P-matrix and the moduli space / matroid polytope for the full graph*)
fullpmatrix=getPmatrix[topleft,topright,bottomleft,bottomright];
dimpmatrix=polytopeDim[fullpmatrix];
fullmodulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,False,BFTgraph];
(*In each of the edge-removals to try out, see which perfect matchings survive*)
survivingperfmatchings=Map[survivingPerfectMatchings[topleft,topright,bottomleft,bottomright,#,False,BFTgraph]&,varstotryout];
(*Also note which rows in P survive (all rows except for those corresponding to the edges we're trying to kill)*)
survivingrows=Map[Complement[Range[Length[varlist]],Flatten[Position[varlist,Alternatives@@#]]]&,varstotryout];
(*In each edge-removal case, if the edge removal decreases the dimension by ONE, use quickReducibility to see whether the resulting graph is reducible or not. Otherwise it's not a valid removal*)
reducibilities=MapThread[Function[{pmatrix,modulispace},Block[{reduc},If[polytopeDim[pmatrix]==dimpmatrix-1,reduc=quickReducibility[pmatrix,modulispace];,reduc=True;];reduc]][fullpmatrix[[#1,#2]],fullmodulispace[[All,#2]]]&,{survivingrows,survivingperfmatchings}];
(*Only keep those cases for which the resulting graph is not reducible*)
removables=varstotryout[[Flatten[Position[reducibilities,False]]]];
,(*we have a non-planar graph, so we need to check things carefully.*)
(*Only keep those cases for which the resulting graph is not reducible and where the dimension has decreased by one*)
dimpmatrix=polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright]];
removables=Cases[varstotryout,zz_/;polytopeDim[getPmatrix[topleft/.Map[#->0&,zz],topright/.Map[#->0&,zz],bottomleft/.Map[#->0&,zz],bottomright]]==dimpmatrix-1&&reducibilityQ[topleft/.Map[#->0&,zz],topright/.Map[#->0&,zz],bottomleft/.Map[#->0&,zz],bottomright,False,BFTgraph,gauging]==False];
];
];
,removables=Null;
];
removables
];

matroidQ[inputmatroid_,checkneeded_:True]:=Block[{matroidcheck,matroidOK},
matroidcheck=matroidViolationCheck[inputmatroid,checkneeded];
If[matroidcheck=!=Null,
matroidOK=matroidViolationCheck[inputmatroid,checkneeded]==={};
,matroidOK=Null;
];
matroidOK
];

matroidViolationCheck[inputmatroid_,checkneeded_:True]:=Module[{inputOK,matroid,matroidelementpairs,checkMatroidPair,badmatroidelementpairs},
inputOK=True;
If[checkneeded,
inputOK=Head[inputmatroid]===List&&And@@Map[Head[#]===List&,inputmatroid]&&And@@Flatten[Map[Head[#]===Integer&,inputmatroid,{2}]];
];
If[inputOK,
matroid=Map[Sort,inputmatroid];
matroidelementpairs=Subsets[matroid,{2}];
checkMatroidPair=Function[{matroidelementpair},
Block[{matroidpairOK,ii,jj,newelement},
matroidpairOK={};
For[ii=1,ii<=Length[matroidelementpair[[1]]],ii++,
newelement=Delete[matroidelementpair[[1]],ii];
For[jj=1,jj<=Length[matroidelementpair[[2]]],jj++,
(*If there is any one that works, this matroid pair is OK.*)
If[MemberQ[matroid,Sort[Append[newelement,matroidelementpair[[2,jj]]]]],
matroidpairOK=Append[matroidpairOK,True];
Break[]
];
If[jj==Length[matroidelementpair[[2]]],matroidpairOK=Append[matroidpairOK,False];];
];
];
For[ii=1,ii<=Length[matroidelementpair[[2]]],ii++,
newelement=Delete[matroidelementpair[[2]],ii];
For[jj=1,jj<=Length[matroidelementpair[[1]]],jj++,
(*If there is any one that works, this matroid pair is OK.*)
If[MemberQ[matroid,Sort[Append[newelement,matroidelementpair[[1,jj]]]]],
matroidpairOK=Append[matroidpairOK,True];
Break[]
];
If[jj==Length[matroidelementpair[[1]]],matroidpairOK=Append[matroidpairOK,False];];
];
];
matroidpairOK=And@@matroidpairOK;
matroidpairOK]
];
badmatroidelementpairs=Cases[matroidelementpairs,zz_/;checkMatroidPair[zz]==False];
,badmatroidelementpairs=Null;
Print["The input must be of the form {{_Integer,_Integer,...},...}"];
];
badmatroidelementpairs
];

(*pluckerRelations[k_Integer,n_Integer]:=pluckerRelations[k,n]=Block[{indexlist1,indexlist2,relations,conditions,i,j,oppositerelations,todelete,ii},
indexlist1=Subsets[Range[n],{k-1}];
indexlist2=Subsets[Range[n],{k+1}];
relations={};
conditions=Map[HoldForm[minor][Sequence@@#]\[Rule]0&,indexlist1];
For[i=1,i<Length[indexlist1]+1,i++,
For[j=1,j<Length[indexlist2]+1,j++,
relations=Join[relations,{Sum[(-1)^(dum-1)(-1)^(PermutationOrder[Ordering[DeleteDuplicates[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]]-1)HoldForm[minor][Sequence@@Union[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]HoldForm[minor][Sequence@@Complement[indexlist2[[j]],{indexlist2[[j,dum]]}]],{dum,k+1}]\[Equal]0}/.conditions];
];
];
relations=DeleteDuplicates[DeleteCases[relations,True]];
(*Remove the ones that are duplicate up to a minus sign*)
oppositerelations=Map[-#[[1]]\[Equal]0&,relations];
todelete={};
For[ii=1,ii\[LessEqual]Length[relations],ii++,
If[FreeQ[todelete,ii],
todelete=Join[todelete,Flatten[Position[oppositerelations,relations[[ii]]]]];
];
];
relations=relations[[Complement[Range[Length[relations]],todelete]]](*/.{minor\[Rule]HoldForm[minor]}*);
relations
];*)

getPremadePluckerRelations[]:=getPremadePluckerRelations[]=Block[{filename,premaderelationsfromfile},
filename=FileNameJoin[{Directory[],"premadePluckerRelations"}];
premaderelationsfromfile=Get[(filename)];
premaderelationsfromfile
];

pluckerRelations[k_Integer,n_Integer]:=pluckerRelations[k,n]=Block[{filename,premaderelations,indexlist1,indexlist2,relations,conditions,i,j,oppositerelations,todelete,ii},
filename=FileNameJoin[{Directory[],"premadePluckerRelations"}];
If[9<=n<=10&&k>2&&k<(n-2)&&FileExistsQ[(filename)],
premaderelations=getPremadePluckerRelations[];
relations=premaderelations[[n-3,k-1]];
,indexlist1=Subsets[Range[n],{k-1}];
indexlist2=Subsets[Range[n],{k+1}];
relations={};
conditions=Map[HoldForm[minor][Sequence@@#]->0&,indexlist1];
For[i=1,i<Length[indexlist1]+1,i++,
For[j=1,j<Length[indexlist2]+1,j++,
relations=Join[relations,{Sum[(-1)^(dum-1) (-1)^(PermutationOrder[Ordering[DeleteDuplicates[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]]-1) HoldForm[minor][Sequence@@Union[Join[indexlist1[[i]],{indexlist2[[j,dum]]}]]]HoldForm[minor][Sequence@@Complement[indexlist2[[j]],{indexlist2[[j,dum]]}]],{dum,k+1}]==0}/.conditions];
];
];
relations=DeleteDuplicates[DeleteCases[relations,True]];
(*Remove the ones that are duplicate up to a minus sign*)
oppositerelations=Map[-#[[1]]==0&,relations];
todelete={};
For[ii=1,ii<=Length[relations],ii++,
If[FreeQ[todelete,ii],
todelete=Join[todelete,Flatten[Position[oppositerelations,relations[[ii]]]]];
];
];
relations=relations[[Complement[Range[Length[relations]],todelete]]](*/.{minor\[Rule]HoldForm[minor]}*);
];
relations
];

independentPluckerRelations[k_Integer,n_Integer]:=Block[{pluckerrel,numindeppluckerrelations,solutions,independentrelations,newsolution,ii},
pluckerrel=pluckerRelations[k,n];
(*The number of independent plucker relations*)
numindeppluckerrelations=Binomial[n,k]-1-k(n-k);
solutions={};
(*If we have any plukcer relations, start solving them*)
If[pluckerrel=!={},
independentrelations=pluckerrel[[{1}]];(*this variable will contain all independent relations*)
newsolution=DeleteCases[Solve[And@@independentrelations],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];(*this variable will contain all independent solutions*)
(*Go through the remaining plucker relations. If the next Plucker relations is not triviliazied by the solutions we already found to the previous relations, add it to the list of independent relations, and solve it.*)
For[ii=2,ii<=Length[pluckerrel],ii++,
If[Simplify[pluckerrel[[ii]]//.solutions]=!=True,
independentrelations=Append[independentrelations,pluckerrel[[ii]]];
newsolution=DeleteCases[Solve[And@@Simplify[independentrelations//.solutions]],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];
(*If we have found as many solutions as there are independent relations in total, stop here, since the remainigs Plucker relations cannot be independent*)
If[Length[solutions]==numindeppluckerrelations,
Break[];
];
];
];
(*Tidy up the solutions so that they all depend on the same set of variables*)
solutions=MapThread[Rule,{Map[#[[1]]&,solutions],Simplify[Map[#[[2]]&,solutions]//.solutions]}];
,(*if there are no Plucker relations, return empty sets*)
independentrelations={};
];
{independentrelations,solutions}
];

makeOrderedPathMatrix[adjacencymatrix_,pathmat_,externalordering_,topleft_,topright_,bottomleft_,bottomright_]:=Block[{adjacencymat,planar,externals,extnum,allperms,numberofperms,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph,defaultorder,ordering,rowordering,orderedpathmat},
adjacencymat=adjacencymatrix;
planar=False;
If[externalordering===Null,
(*If we haven't specified an external ordering, make a cyclic ordering when planar. If not planar, pick a default ordering based on the Kasteleyn*)
(*Let's see if we can find a planar cyclic ordering*)
externals=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];(*These are the node numbers corresponding to external nodes*)
extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
allperms=Permutations[Range[extnum-1]];
numberofperms=Length[allperms];
permutations=Map[Append[#,extnum]&,allperms[[DeleteDuplicates[MapThread[Sort[{#1,#2}][[1]]&,{Range[numberofperms],Ordering[Map[Reverse[#]&,allperms]]}]]]]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
If[permutations[[1]]==={1,2},
externaladjacencyseed={{0,1},{1,0}};
,If[permutations[[1]]==={1},
externaladjacencyseed={1};
,externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
];
];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],(*we found a cyclic planar ordering!*)
planar=True;
ordering=Ordering[permutations[[ii]]];
rowordering=Ordering[Flatten[Map[Position[ordering,#]&,Flatten[Map[Position[Transpose[pathmat],#]&,IdentityMatrix[Length[pathmat]]]]]]];
orderedpathmat=pathmat[[rowordering,ordering]];
Break[];
];
];
If[planar==False,(*if the graph is non-planar, pick the default ordering*)
orderedpathmat=pathmat;
];
,(*if we specified an ordering, use that instead. Here we don't care whether the graph is planar or not, since the user is forced to specify all the boundaries and cuts etc.*)
(*externalNodeOrderingDefault is the same as that chosen by pathMatrix*)
defaultorder=externalNodeOrderingDefault[topleft,topright,bottomleft,bottomright];
ordering=externalordering/.MapThread[Rule,{defaultorder,Range[Length[defaultorder]]}];
rowordering=Ordering[Flatten[Map[Position[ordering,#]&,Flatten[Map[Position[Transpose[pathmat],#]&,IdentityMatrix[Length[pathmat]]]]]]];
orderedpathmat=pathmat[[rowordering,ordering]];
];
{orderedpathmat,planar}
];

spiralInList[vertexlist_]:=Block[{remainingvertices,nextnode,finalvertexlist,polardistances},
remainingvertices=vertexlist;
(*The first node is the one with the largest y-coordinate*)
nextnode=Cases[remainingvertices,{_,Max[Map[#[[2]]&,remainingvertices]]}][[1]];
finalvertexlist={nextnode+{0,0.1},nextnode};
remainingvertices=DeleteCases[remainingvertices,nextnode];
While[remainingvertices=!={},
polardistances=Map[{#[[1]],Mod[#[[2]]-ToPolarCoordinates[finalvertexlist[[-2]]-nextnode][[2]],2Pi]}&,Map[ToPolarCoordinates[#-nextnode]&,remainingvertices]];
(*The next node is the first one reached going radially and clockwise from the current node*)
nextnode=Cases[polardistances,{_,Max[Map[#[[2]]&,polardistances]]}];
(*If there are multiple ones with the same angle, pick the nearest one*)
nextnode=Cases[nextnode,{Min[Map[#[[1]]&,nextnode]],_}][[1]];
nextnode=remainingvertices[[Position[polardistances,nextnode][[1,1]]]];
finalvertexlist=Append[finalvertexlist,nextnode];
remainingvertices=DeleteCases[remainingvertices,nextnode];
];
finalvertexlist=Delete[finalvertexlist,1];
finalvertexlist
];

rotateExternalVertices[verticespos_,edgepos_,externalnodenumbers_]:=Module[{externaledges,tocriticalnode,externalvertices,cutcoordinates,freestandingexternalvertices,doesitavoidmycriticalnode,corrections,jj,badexternalnodes,rotateExternalEdge,segmentCrossQ,newverticespos,newedgepos,iterationvector,accidentallycrossededges,newexternaledgecoords,edgeswemightcrossnow,newexternalnodesrule},
(*We need to see if any of the cuts end up going through nodes attached to external nodes. If they do, things get complicated so it's better to rotate the external node to make sure the cut doesn't do this*)
externaledges=Cases[edgepos,{___,UndirectedEdge[Alternatives@@externalnodenumbers,_]}|{___,UndirectedEdge[_,Alternatives@@externalnodenumbers]}];
(*Our cuts may never go through the "critical nodes", i.e.  those nodes attached to external nodes*)
tocriticalnode=Map[Rule@@#&,Join[Map[#[[1]]&,externaledges],Map[Reverse[#[[1]]]&,externaledges]]];
(*Now we'll construct the cuts: they will run directly between the external vertices, since the boundaries are so tiny*)
(*We'll make a sequence of boundaries connected by cuts. We'll start with the external node with the highest y-coordinate, and proceed along external nodes as we spiral in to the middle. This ensures that the cuts never cross each other*)
externalvertices=Map[#[[2]]&,Cases[verticespos,{Alternatives@@externalnodenumbers,___}]];
externalvertices=spiralInList[externalvertices];
(*We may now form the cuts: they are (n-1) sequential pairs of externalvertices*)
cutcoordinates=Table[{externalvertices[[iii]],externalvertices[[iii+1]]},{iii,Length[externalvertices]-1}];
(*If we go through a critical node we need to take the external edges and rotate them. We must stay within the same face and also not cross any other edges.*)
(*Let's find the coordinates of those external nodes whose position forces a cut do run parallel over the external edge*)
(*Sometimes an external vertex is not connected to an external edge*)
freestandingexternalvertices=Cases[externalvertices,Except[Alternatives@@Map[Sequence@@#[[1]]&,externaledges]]];
doesitavoidmycriticalnode=Map[Table[Solve[SetPrecision[#[[1]]+param(#[[2]]-#[[1]])==(#[[iii]]/.tocriticalnode)&&param<=1.,10],param]==={},{iii,2}]&,cutcoordinates];
corrections=Map[#&,Position[cutcoordinates,Alternatives@@freestandingexternalvertices]];
For[jj=1,jj<=Length[corrections],jj++,
doesitavoidmycriticalnode[[Sequence@@corrections[[jj]]]]=True;
];
badexternalnodes=Map[cutcoordinates[[Sequence@@#]]&,DeleteDuplicates[Position[doesitavoidmycriticalnode,False],First[#1]==First[#2]&]];
(*This function takes an external edge, finds the two nearest edges to it (coming from the same critical node), determines which ones has the smallest angle to our external edge, and rotates the external edge 95% (to the power "iteration") of the way there*)
newverticespos=verticespos;
newedgepos=edgepos;
rotateExternalEdge=Function[{inputexternaledge,iteration},
(*This function needs tocriticalnode, newedgepos*)
Block[{criticalnode,externaledgenewcoordinates,otheredgesnewcoordinates,rotatedotheredgesnewcoordinates,anglesotheredges,smallestangle,newexternaledgeposition},
criticalnode=inputexternaledge/.tocriticalnode;
externaledgenewcoordinates=ToPolarCoordinates[inputexternaledge-criticalnode];
otheredgesnewcoordinates=Map[DeleteCases[#,{0.,0.}][[1]]&,Map[#-criticalnode&,DeleteCases[Map[#[[1]]&,Cases[newedgepos,{{___,criticalnode},___}|{{criticalnode,___},___}]],{___,inputexternaledge}|{inputexternaledge,___}],{2}]];
rotatedotheredgesnewcoordinates=Map[ToPolarCoordinates[RotationMatrix[-externaledgenewcoordinates[[2]]].#]&,otheredgesnewcoordinates];
anglesotheredges=Map[Mod[#[[2]],2Pi]&,rotatedotheredgesnewcoordinates];
anglesotheredges={Min[anglesotheredges],Max[anglesotheredges]-2Pi};
smallestangle=anglesotheredges[[Ordering[Abs[anglesotheredges]][[1]]]];
newexternaledgeposition=criticalnode+RotationMatrix[Power[0.95,iteration]smallestangle].(inputexternaledge-criticalnode);
inputexternaledge->newexternaledgeposition]
];
(*This function tells you whether two generic segments cross*)
segmentCrossQ=Function[{edge1coords,edge2coords},
Block[{matrixtoinvert,crossdistance,crossq},
matrixtoinvert={{edge1coords[[1,1]]-edge1coords[[2,1]],edge2coords[[2,1]]-edge2coords[[1,1]]},{edge1coords[[1,2]]-edge1coords[[2,2]],edge2coords[[2,2]]-edge2coords[[1,2]]}};
If[N[Chop[Det[matrixtoinvert]]]=!=0.,(*if the matrix is invertible*)
crossdistance=Inverse[matrixtoinvert].{edge1coords[[1,1]]-edge2coords[[1,1]],edge1coords[[1,2]]-edge2coords[[1,2]]};
crossq=And@@Map[(#>=0)&&(#<=1)&,crossdistance];
,(*the edges are parallel*)
If[(*Solve[edge1coords[[1]]+param(edge1coords[[2]]-edge1coords[[1]])\[Equal]edge2coords[[1]]&&0\[LessEqual]param\[LessEqual]1,param]=!={}||Solve[edge1coords[[1]]+param(edge1coords[[2]]-edge1coords[[1]])\[Equal]edge2coords[[2]]&&0\[LessEqual]param\[LessEqual]1,param]=!={},*)Solve[SetPrecision[edge1coords[[1]]+param(edge1coords[[2]]-edge1coords[[1]])==edge2coords[[1]]&&0<=param<=1,10],param]=!={}||Solve[SetPrecision[edge1coords[[1]]+param(edge1coords[[2]]-edge1coords[[1]])==edge2coords[[2]]&&0<=param<=1,10],param]=!={},
(*the edges are parallel and overlap*)
crossq=True;
,crossq=False;];
];
crossq]
];
While[badexternalnodes=!={},
(*Now let's rotate until all badexternalnodes nodes have been rotated, without crossing any other edges*)
iterationvector=ConstantArray[1,Length[badexternalnodes]];(*iterationvector keeps track of how many times we've tried to rotate a node without accidentally crossing already existing edges. Each time we iterate we rotate it slightly less*)
accidentallycrossededges=True;
While[Or@@accidentallycrossededges,
newexternaledgecoords=MapThread[{#1/.tocriticalnode,rotateExternalEdge[#1,#2][[2]]}&,{badexternalnodes,iterationvector}];
edgeswemightcrossnow=Map[#[[1]]&,Map[DeleteCases[newedgepos,{{#,___},___}|{{___,#},___}]&,badexternalnodes/.tocriticalnode],{2}];
accidentallycrossededges=MapThread[Or@@Table[segmentCrossQ[#1[[iii]],#2],{iii,Length[#1]}]&,{edgeswemightcrossnow,newexternaledgecoords}];
iterationvector=iterationvector+accidentallycrossededges/.{False->0,True->1};
];
newexternalnodesrule=MapThread[rotateExternalEdge[#1,#2]&,{badexternalnodes,iterationvector}];
newverticespos=newverticespos/.newexternalnodesrule;
newedgepos=newedgepos/.newexternalnodesrule;
externalvertices=spiralInList[externalvertices/.newexternalnodesrule];
cutcoordinates=Table[{externalvertices[[iii]],externalvertices[[iii+1]]},{iii,Length[externalvertices]-1}];
tocriticalnode=tocriticalnode/.newexternalnodesrule;
doesitavoidmycriticalnode=Map[Table[Solve[#[[1]]+param(#[[2]]-#[[1]])==(#[[iii]]/.tocriticalnode),param]==={},{iii,2}]&,cutcoordinates];
corrections=Map[#&,Position[cutcoordinates,Alternatives@@freestandingexternalvertices]];
For[jj=1,jj<=Length[corrections],jj++,
doesitavoidmycriticalnode[[Sequence@@corrections[[jj]]]]=True;
];
badexternalnodes=Map[cutcoordinates[[Sequence@@#]]&,DeleteDuplicates[Position[doesitavoidmycriticalnode,False],First[#1]==First[#2]&]];
];
{newverticespos,newedgepos}
];

makePlanarGraph[graph_,topleft_,topright_,bottomleft_,bottomright_]:=Module[{planargraph,verticespos,edgepos,externalnodenumbers,verticestocoords,externalvertices,externaledges,decreaseExternalEdgeLength,shrinkedgesrule},
planargraph=Graph[graph,GraphLayout->"PlanarEmbedding"];
verticespos=MapThread[{#1,#2}&,{Range[Length[GraphEmbedding[planargraph]]],GraphEmbedding[planargraph]}];
edgepos=Map[{{verticespos[[#[[1]],2]],verticespos[[#[[2]],2]]},#}&,EdgeList[planargraph]];
edgepos=DeleteDuplicates[edgepos];(*in case there are bubbles*)
(*Now decrease the length of all external edges by about 14%, since PlanarEmbedding tries to put everything as collinear as possible, which is problematic when we make cuts*)
externalnodenumbers=Join[Range[Length[bottomleft]]+Length[topleft],Range[Dimensions[topright][[2]]]+Total[Dimensions[topleft]]+Length[bottomleft]];
verticestocoords=Map[Rule@@#&,verticespos];
externalvertices=externalnodenumbers/.verticestocoords;
externaledges=Cases[edgepos,{___,UndirectedEdge[Alternatives@@externalnodenumbers,_]}|{___,UndirectedEdge[_,Alternatives@@externalnodenumbers]}];
decreaseExternalEdgeLength=Function[{inputedge,decreasequantity},
(*This function needs externalvertices to be accurate in order to work*)
Block[{tosubtractcoords,externalnodepolarcoords,newposition,newpositionrule},
tosubtractcoords=Cases[inputedge[[1]],Except[Alternatives@@externalvertices]][[1]];
externalnodepolarcoords=ToPolarCoordinates[DeleteCases[Map[#-tosubtractcoords&,inputedge[[1]]],{0.,0.}][[1]]];
newposition=tosubtractcoords+FromPolarCoordinates[{(1.-decreasequantity)externalnodepolarcoords[[1]],externalnodepolarcoords[[2]]}];
newpositionrule=Cases[inputedge[[1]],Except[tosubtractcoords]][[1]]->newposition;
newpositionrule]
];
shrinkedgesrule=Map[decreaseExternalEdgeLength[#,0.14]&,externaledges];
verticespos=verticespos/.shrinkedgesrule;
edgepos=edgepos/.shrinkedgesrule;
{verticespos,edgepos}=rotateExternalVertices[verticespos,edgepos,externalnodenumbers];
{verticespos,edgepos}
];

makeAutomaticBoundariesAndCuts[graph_,topleft_,topright_,bottomleft_,bottomright_]:=Module[{verticespos,edgepos,externalnodenumbers,externalvertices,coordstononumbers,boundaries,cutcoordinates,cutcoordinatesandnodes,edgesCrossQ,crossedEdges,cutsedgecrossings,extraCutEdges,extracrossededges,kasteleyn,bigkasteleyn,nameUndirectedEdges,edgenamerule,boundarypaircuts},
If[PlanarGraphQ[graph],
(*We shall begin by drawing out the graph such that no edges cross. The special way in which we draw it will also be useful to us when we make cuts between boundaries*)
{verticespos,edgepos}=makePlanarGraph[graph,topleft,topright,bottomleft,bottomright];
(*Now we have the vertices and edges for a good embedding with no edge crossings*)
(*Each external vertex will be seen as having its own tiny boundary attached to it. We'll order the nodes according to the cuts. To avoid the cuts crossing each other, we'll start from an external node far out and spiral in: this determines the order of externalvertices*)
externalnodenumbers=Join[Range[Length[bottomleft]]+Length[topleft],Range[Dimensions[topright][[2]]]+Total[Dimensions[topleft]]+Length[bottomleft]];
externalvertices=Map[#[[2]]&,Cases[verticespos,{Alternatives@@externalnodenumbers,___}]];
externalvertices=spiralInList[externalvertices];
(*We may now form the tiny boundaries around each external node, and have them in the right order*)
coordstononumbers=Map[#[[2]]->#[[1]]&,verticespos];
boundaries=Transpose[{(externalvertices/.coordstononumbers)}];
(*Now we'll construct the cuts: they will run directly between the external vertices, since the boundaries are so tiny. The cuts are are (n-1) sequential pairs of externalvertices*)
cutcoordinates=Table[{externalvertices[[iii]],externalvertices[[iii+1]]},{iii,Length[externalvertices]-1}];
(*For convenience we'll also append to each of these pairs the two node numbers that they represent*)
cutcoordinatesandnodes=MapThread[{#1,#2}&,{cutcoordinates,Map[Alternatives@@#&,cutcoordinates/.coordstononumbers]}];
(*Now we need to see which edges are crossed by each cut (remember that in each cut we don't want to consider cutting edges that pass through the two external nodes)*)
(*This function tells you whether a cut crosses an edge*)
edgesCrossQ=Function[{cutcoords,edgecoords},
Block[{matrixtoinvert,crossdistance,newcutcoords,crossq},
matrixtoinvert={{cutcoords[[1,1]]-cutcoords[[2,1]],edgecoords[[2,1]]-edgecoords[[1,1]]},{cutcoords[[1,2]]-cutcoords[[2,2]],edgecoords[[2,2]]-edgecoords[[1,2]]}};
If[N[Chop[Det[matrixtoinvert]]]=!=0.,(*if the matrix is invertible*)
crossdistance=Inverse[matrixtoinvert].{cutcoords[[1,1]]-edgecoords[[1,1]],cutcoords[[1,2]]-edgecoords[[1,2]]};
If[crossdistance[[2]]==1.||crossdistance[[2]]==0.,(*we are touching the endpoint of an edge*)
(*In this case we should slightly shift the cut downwards and so that it doesn't go right through the node*)
newcutcoords=Map[#-{0,0.05}&,cutcoords];
matrixtoinvert={{newcutcoords[[1,1]]-newcutcoords[[2,1]],edgecoords[[2,1]]-edgecoords[[1,1]]},{newcutcoords[[1,2]]-newcutcoords[[2,2]],edgecoords[[2,2]]-edgecoords[[1,2]]}};
If[N[Chop[Det[matrixtoinvert]]]=!=0.,
crossdistance=Inverse[matrixtoinvert].{newcutcoords[[1,1]]-edgecoords[[1,1]],newcutcoords[[1,2]]-edgecoords[[1,2]]};
If[crossdistance[[2]]==1.||crossdistance[[2]]==0.,(*we are STILL touching the endpoint of an edge*)
(*In this case we should slightly shift the cut to the right and so that it doesn't go right through the node*)
newcutcoords=Map[#+{0.05,0}&,newcutcoords];
matrixtoinvert={{newcutcoords[[1,1]]-newcutcoords[[2,1]],edgecoords[[2,1]]-edgecoords[[1,1]]},{newcutcoords[[1,2]]-newcutcoords[[2,2]],edgecoords[[2,2]]-edgecoords[[1,2]]}};
If[N[Chop[Det[matrixtoinvert]]]=!=0.,
crossdistance=Inverse[matrixtoinvert].{newcutcoords[[1,1]]-edgecoords[[1,1]],newcutcoords[[1,2]]-edgecoords[[1,2]]};
,If[Solve[newcutcoords[[1]]+param(newcutcoords[[2]]-newcutcoords[[1]])==edgecoords[[1]]&&0<=param<=1,param]=!={}||Solve[newcutcoords[[1]]+param(newcutcoords[[2]]-newcutcoords[[1]])==edgecoords[[2]]&&0<=param<=1,param]=!={},
(*the edges are parallel and overlap*)
crossdistance={0.5,0.5};
,crossdistance={2.,2.}];
];
];
,If[Solve[newcutcoords[[1]]+param(newcutcoords[[2]]-newcutcoords[[1]])==edgecoords[[1]]&&0<=param<=1,param]=!={}||Solve[newcutcoords[[1]]+param(newcutcoords[[2]]-newcutcoords[[1]])==edgecoords[[2]]&&0<=param<=1,param]=!={},
(*the edges are parallel and overlap*)
crossdistance={0.5,0.5};
,crossdistance={2.,2.}];
];
];
crossq=And@@Map[(#>=0)&&(#<=1)&,crossdistance];
,(*the edges are parallel*)
If[Solve[cutcoords[[1]]+param(cutcoords[[2]]-cutcoords[[1]])==edgecoords[[1]]&&0<=param<=1,param]=!={}||Solve[cutcoords[[1]]+param(cutcoords[[2]]-cutcoords[[1]])==edgecoords[[2]]&&0<=param<=1,param]=!={},
(*the edges are parallel and overlap*)
crossq=True;
,crossq=False;];
];
crossq]
];
(*This function takes a cut and tells you which UndirectedEdges in the graph it crosses*)
crossedEdges=Function[{cutinfo},
Map[#[[2]]&,DeleteCases[Cases[edgepos,zz_/;edgesCrossQ[cutinfo[[1]],zz[[1]]]],{___,UndirectedEdge[_,cutinfo[[2]]]}|{___,UndirectedEdge[cutinfo[[2]],_]}]]
];
(*Now we're able to determine which edges are crossed by each cut*)
cutsedgecrossings=Map[crossedEdges,cutcoordinatesandnodes];
(*In order to maintain the ordering of nodes we determined with our cuts, sometimes we need an external edge to be crossed an additional time by one of the two cuts in order to keep its position in the order of external nodes*)
(*This function takes a pair of cuts and returns a list containing the additional edges that get crossed. We should assume that it is the first of the pair of cuts that crosses the edge*)
extraCutEdges=Function[{pairofcutscoordinates},
Block[{pairofcuts,externaledgename,externaledge,cutangles,edgeangle,rotatedcutangles,rotatededgeangle,return},
pairofcuts=pairofcutscoordinates;
externaledgename=Cases[edgepos,{{___,pairofcuts[[1,2]],___},___}];
If[externaledgename=!={},
externaledgename=externaledgename[[1,2]];
externaledge=Cases[edgepos,{{___,pairofcuts[[1,2]],___},___}][[1,1]];
externaledge=DeleteCases[Map[#-pairofcuts[[1,2]]&,externaledge],{0.,0.}];
pairofcuts=DeleteCases[Sequence@@@Map[#-pairofcuts[[1,2]]&,pairofcuts,{2}],{0.,0.}];
cutangles=Map[Mod[#[[2]],2Pi]&,Map[ToPolarCoordinates,pairofcuts]];
edgeangle=Map[Mod[#[[2]],2Pi]&,Map[ToPolarCoordinates,externaledge]];
rotatedcutangles=Mod[cutangles-cutangles[[1]],2Pi];
rotatededgeangle=Mod[edgeangle-cutangles[[1]],2Pi];
If[rotatededgeangle[[1]]<rotatedcutangles[[2]],
return={externaledgename};
,return={};
];
,return={};];
return]
];
(*For each pair of cuts, we now get the additional edges that get crossed*)
extracrossededges=Map[extraCutEdges,Table[{cutcoordinates[[iii]],cutcoordinates[[iii+1]]},{iii,Length[cutcoordinates]-1}]];
(*These are added to cutsedgecrossings. Since the last cut never crosses an edge, add an empty list*)
extracrossededges=Append[extracrossededges,{}];
cutsedgecrossings=Map[DeleteDuplicates,MapThread[Join,{cutsedgecrossings,extracrossededges}]];
(*We need to translate this into actual edge variable names*)
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
bigkasteleyn=Join[kasteleyn,Transpose[kasteleyn]];
nameUndirectedEdges=Function[{undirectededge},
undirectededge->Sequence@@Intersection@@Map[Variables[bigkasteleyn[[#]]]&,List@@undirectededge]
];
edgenamerule=Map[nameUndirectedEdges,DeleteDuplicates[EdgeList[graph]]];
cutsedgecrossings=Map[#->-#&,cutsedgecrossings/.edgenamerule,{2}];
boundarypaircuts=MapThread[Rule,{Table[{boundaries[[iii]],boundaries[[iii+1]]},{iii,Length[boundaries]-1}],cutsedgecrossings}];
,Print["It must be possible to embed the graph on genus zero without any edges crossing."];
boundaries=Null;
boundarypaircuts=Null;
];
{boundaries,boundarypaircuts}
];

getGrassmannian[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,externalordering_:Null,boundarylist_:Null,boundarycutreplacements_:Null]/;(externalordering===Null&&boundarylist===Null&&boundarycutreplacements===Null||externalordering=!=Null&&boundarylist=!=Null&&boundarycutreplacements=!=Null):=Module[{adjacencymat,graph,planar,perfmatchings,referenceperfmatch,pathmat,orderedpathmat,loopdenominator,looplist,loopreplacement,loop,loopsigns,grassmannianmatrix,sourcenodes,boundaries,boundarypaircuts,pathmatorder,neworder,newroworder,cutSequence,finalloopsignsmatrix,implementFinalLoops,globalsigns},
(*Let's first see if the graph can be embedded on genus zero*)
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
planar=False;
If[PlanarGraphQ[graph],
(*If it can be embedded on genus zero make the path matrix*)
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
pathmat=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
If[pathmat==={},
grassmannianmatrix={};
,(*We shall now pick an ordering of external edges for this path matrix, depending on whether the user specified an ordering or not*)
{orderedpathmat,planar}=makeOrderedPathMatrix[adjacencymat,pathmat,externalordering,topleft,topright,bottomleft,bottomright];
(*Now we have the ordered path matrix*)
(*Now we will plug in the correct signs. We begin with those belonging to loops (excluding those loops formed by closing the path between multiple boundaries)*)
(*First find the loops, if any*)
(*loopdenominator=Expand[1/Expand[Simplify[Det[connectivityMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch]]]]];*)
loopdenominator=getLoopDenominator[topleft,topright,bottomleft,bottomright,referenceperfmatch];
If[Head[loopdenominator]===Plus,
(*we have multiple terms*)
looplist=-DeleteCases[List@@loopdenominator,1];
loopreplacement=MapThread[Rule,{looplist,Table[loop[iii],{iii,Length[looplist]}]}];
,looplist={};
loopreplacement={};
];
(*Now use a function to add the loop signs into the matrix*)
loopsigns=Function[{matrixentry},
Block[{terms},
If[Head[matrixentry]===Integer,
terms={matrixentry};
,If[Head[matrixentry]===Plus,
(*we have multiple terms*)
terms=Expand[Simplify[(List@@matrixentry)loopdenominator]]/loopdenominator;
,terms={Expand[Simplify[matrixentry loopdenominator]]/loopdenominator};
];
terms=terms//.loopreplacement;
terms=terms/.Map[#[[2]]->-#[[2]]&,loopreplacement];
];
Total[terms]]
];
(*We'll now put in the loop signs, including those from loops formed by closing the path between multiple boundaries*)
grassmannianmatrix=Map[loopsigns,orderedpathmat,{2}];
sourcenodes=Flatten[Map[Position[Transpose[orderedpathmat],#]&,IdentityMatrix[Length[orderedpathmat]]]];
If[planar==False,
If[externalordering===Null,
{boundaries,boundarypaircuts}=makeAutomaticBoundariesAndCuts[graph,topleft,topright,bottomleft,bottomright];
(*We'll need to re-rder the grassmannian nodes now that we have a new order determined by our cuts*)
pathmatorder=Sort[Flatten[boundaries]];
neworder=Flatten[boundaries]/.MapThread[Rule,{pathmatorder,Range[Length[pathmatorder]]}];
newroworder=Ordering[Flatten[Map[Position[neworder,#]&,sourcenodes]]];
sourcenodes=Sort[Flatten[Map[Position[neworder,#]&,sourcenodes]]];
grassmannianmatrix=grassmannianmatrix[[newroworder,neworder]];
,{boundaries,boundarypaircuts}={boundarylist,boundarycutreplacements};
];
(*This function takes a pair of external nodes and returns a list of replacement lists to be used on the grassmannian. These replacements represent all the cuts required to go from one boundary to the next*)
cutSequence=Function[{externaledgepair},
Block[{bigkasteleyn,externalnodepair,boundariestoconnect,boundarynumberrule,boundarypairnumbers,shortestpath,cutpath},
bigkasteleyn=Join[joinupKasteleyn[topleft,topright,bottomleft,bottomright],Transpose[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]];
externalnodepair=Flatten[Map[Intersection[#,Flatten[boundaries]]&,Map[#[[1]]&,Map[Position[bigkasteleyn,#]&,externaledgepair],{2}]]];
boundariestoconnect=Cases[boundaries,zz_/;MemberQ[zz,Alternatives@@externalnodepair]];
If[Length[boundariestoconnect]>1,(*the nodes are on different boundaries*)
boundarynumberrule=MapThread[Rule,{boundaries,Range[Length[boundaries]]}];
boundariestoconnect=boundariestoconnect/.boundarynumberrule;
boundarypairnumbers=Map[#[[1]]&,boundarypaircuts]/.boundarynumberrule;
(*Let's now find the shortest path between these two boundaries, using our cuts*)
shortestpath=FindShortestPath[Graph[Map[UndirectedEdge@@#&,boundarypairnumbers]],Sequence@@boundariestoconnect];
(*Turn this sequence of boundaries into pairs that can be identified with cuts*)
shortestpath=Table[{shortestpath[[iii]],shortestpath[[iii+1]]},{iii,Length[shortestpath]-1}];
(*This is the sequence of cuts we must do to go from one boundary to the other. These cuts must be performed sequentially, not all at once (in case some edges get cut multiple times)!*)
cutpath=shortestpath/.(boundarypaircuts/.boundarynumberrule);
,(*the two external nodes are on the same boundary*)
cutpath={};
];
cutpath]
];
finalloopsignsmatrix=Map[cutSequence[Intersection[Variables[#],Variables[Join[topright,bottomleft]]]]&,grassmannianmatrix,{2}];
implementFinalLoops=Function[{matrixentry,replacementlists},
Block[{newmatrixentry,ii},
newmatrixentry=matrixentry;
For[ii=1,ii<=Length[replacementlists],ii++,
newmatrixentry=newmatrixentry/.replacementlists[[ii]];
];
newmatrixentry]
];
grassmannianmatrix=MapThread[implementFinalLoops[#1,#2]&,{grassmannianmatrix,finalloopsignsmatrix},2];
];
(*We have finished putting in signs due to loops*)
(*We'll now put in the global signs on matrix entries*)
globalsigns=Partition[Map[Power[-1,Count[sourcenodes,zz_/;zz>#[[1]]&&zz<#[[2]]]]&,Map[Sort,Tuples[{sourcenodes,Range[Dimensions[grassmannianmatrix][[2]]]}]]],Dimensions[grassmannianmatrix][[2]]];
grassmannianmatrix=(grassmannianmatrix globalsigns)/.Map[#[[2]]->#[[1]]&,loopreplacement];
];
,Print["This graph has no perfect matchings"];
grassmannianmatrix=Null;
];
,(*If it cannot be embedded on genus zero,stop here*)
Print["The diagram cannot be embedded on genus zero."];
grassmannianmatrix=Null;
];
grassmannianmatrix
];

pluckerCoordinates[topleft_,topright_,bottomleft_,bottomright_,referencematching_:Null,withsigns_:False]:=Module[{perfmatchings,referenceperfmatch,Cmatrix,minors,pathmat},
If[referencematching===Null,
perfmatchings=perfectMatchings[topleft,topright,bottomleft,bottomright];
If[perfmatchings=!={},
referenceperfmatch=perfmatchings[[lowNumberLoopsPM[topleft,topright,bottomleft,bottomright]]];
,referenceperfmatch=0;
];
,referenceperfmatch=referencematching;
];
If[referenceperfmatch=!=0,
If[withsigns,
Cmatrix=getGrassmannian[topleft,topright,bottomleft,bottomright,referenceperfmatch];
,Cmatrix=pathMatrix[topleft,topright,bottomleft,bottomright,referenceperfmatch];
];
If[Cmatrix==={},
minors={};
,minors=Expand[Simplify[Minors[Cmatrix,Length[Cmatrix]][[1]]]];
];
,minors=Null;
];
minors
];

externalEdgeOrderingGrassmanian[topleft_,topright_,bottomleft_,bottomright_]:=Block[{ordering,adjacencymat,graph,planar,externals,extnum,allperms,numberofperms,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph,verticespos,edgepos,externalvertices,bigkasteleyn},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];
planar=False;
If[PlanarGraphQ[graph],(*the graph can be embedded on genus zero, but may still be non-planar*)
(*Make a cyclic ordering when planar. If not planar, pick a default ordering based on the Kasteleyn*)
(*Let's see if we can find a planar cyclic ordering*)
externals=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];(*These are the node numbers corresponding to external nodes*)
ordering=(*Flatten[DeleteCases[Join[bottomleft,Transpose[topright]],0,{2}]]*)externals;
If[externals==={},
ordering={};
,extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
allperms=Permutations[Range[extnum-1]];
numberofperms=Length[allperms];
permutations=Map[Append[#,extnum]&,allperms[[DeleteDuplicates[MapThread[Sort[{#1,#2}][[1]]&,{Range[numberofperms],Ordering[Map[Reverse[#]&,allperms]]}]]]]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
If[permutations[[1]]==={1,2},
externaladjacencyseed={{0,1},{1,0}};
,If[permutations[[1]]==={1},
externaladjacencyseed={1};
,externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
];
];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],(*we found a cyclic planar ordering!*)
planar=True;
ordering=ordering[[Ordering[permutations[[ii]]]]];
Break[];
];
];
(*If the graph was planar, we now have the ordering of external nodes*)
If[planar==False,
{verticespos,edgepos}=makePlanarGraph[graph,topleft,topright,bottomleft,bottomright];
externalvertices=Map[#[[2]]&,Cases[verticespos,{Alternatives@@externals,___}]];
externalvertices=spiralInList[externalvertices];
ordering=ordering[[(externalvertices/.Map[#[[2]]->#[[1]]&,verticespos])/.MapThread[Rule,{externals,Range[Length[externals]]}]]];
];
bigkasteleyn=Join[joinupKasteleyn[topleft,topright,bottomleft,bottomright],Transpose[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]];
ordering=Map[#[[1,1]]->#[[2]]&,DeleteCases[MapThread[Rule,{Map[Variables[bigkasteleyn[[#]]]&,ordering],Range[Length[ordering]]}],{}->___]];
];
,(*If it cannot be embedded on genus zero,stop here*)
Print["The diagram cannot be embedded on genus zero."];
ordering=Null;
];
ordering
];

externalNodeOrderingGrassmanian[topleft_,topright_,bottomleft_,bottomright_]:=Block[{ordering,adjacencymat,graph,planar,externals,extnum,allperms,numberofperms,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph,verticespos,edgepos,externalvertices},
ordering=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];
planar=False;
If[PlanarGraphQ[graph],(*the graph can be embedded on genus zero, but may still be non-planar*)
(*Make a cyclic ordering when planar. If not planar, pick a default ordering based on the Kasteleyn*)
(*Let's see if we can find a planar cyclic ordering*)
externals=Join[Range[Length[topleft]+1,Length[topleft]+Length[bottomleft]],Range[Total[Dimensions[topleft]]+Length[bottomleft]+1,Total[Dimensions[topleft]]+Length[bottomleft]+Dimensions[topright][[2]]]];(*These are the node numbers corresponding to external nodes*)
If[externals==={},
ordering={};
,extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
allperms=Permutations[Range[extnum-1]];
numberofperms=Length[allperms];
permutations=Map[Append[#,extnum]&,allperms[[DeleteDuplicates[MapThread[Sort[{#1,#2}][[1]]&,{Range[numberofperms],Ordering[Map[Reverse[#]&,allperms]]}]]]]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
If[permutations[[1]]==={1,2},
externaladjacencyseed={{0,1},{1,0}};
,If[permutations[[1]]==={1},
externaladjacencyseed={1};
,externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
];
];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],(*we found a cyclic planar ordering!*)
planar=True;
ordering=ordering[[Ordering[permutations[[ii]]]]];
Break[];
];
];
(*If the graph was planar, we now have the ordering of external nodes*)
If[planar==False,
{verticespos,edgepos}=makePlanarGraph[graph,topleft,topright,bottomleft,bottomright];
externalvertices=Map[#[[2]]&,Cases[verticespos,{Alternatives@@externals,___}]];
externalvertices=spiralInList[externalvertices];
ordering=ordering[[(externalvertices/.Map[#[[2]]->#[[1]]&,verticespos])/.MapThread[Rule,{externals,Range[Length[externals]]}]]];
];
];
,(*If it cannot be embedded on genus zero,stop here*)
Print["The diagram cannot be embedded on genus zero."];
ordering=Null;
];
ordering
];

getStratification[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{checkOK,stratification,xlistandPmatrix,modulispace,startingplanarity,removable,topdim,varlist,makeDaughterGraphs,planarReducibility,tofixlevels,maxnonplanardimension,level,nonplanarpositions,planarboundaries,nonplanarboundaries,templevel,boundarykillededges,newplanarity,planarpositions,fix,identremovable,patternidentremovable,dim,locationofparents,thislevelspositions},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
(*We begin by making the face lattice of the matching polytope. Each element in the face lattice will be composed of three objects: the perfect matching matrix P, the moduli space/matroid polytope, and the answer to planarityQ. This will allow us to construct the face lattice while computing the perfect matchings and matrix P as few times as possible (not once per subgraph!)*)
(*We'll start with making the top-dimensional element. In P we shall also tag on which edges correspond to each row, by making the first element of each row the edge name*)
If[Dimensions[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]][[2]]===0,
stratification={};
,xlistandPmatrix=Join[Transpose[{Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]}],getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph],2];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
(*This will be the top-dimensional element in our stratification*)
startingplanarity=planarityQ[topleft,topright,bottomleft,bottomright];
If[BFTgraph||startingplanarity,
removable[0]={{xlistandPmatrix,modulispace,True}};
(*Since planarity is inherited by subgraphs, this means we'll never have to assess planarity again and we can treat everything as planar. This will mean we can assess reducibility very fast and easily, and identify everything according to their moduli space.*)
,removable[0]={{xlistandPmatrix,modulispace,startingplanarity}};
];
(*We'll save some basic information to avoid having to evaluate it many times*)
topdim=polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]];
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
(*For each element in the face lattice, we will need to find all of its boundaries. These are found by deleting edges. makeDaughterGraphs takes an element in the face lattice and removes all possible edges, making potential boundaries (which will need to be verified). Initially the planarity of the subgraphs is inherited, i.e. is declared equal to the originating graph.*)
makeDaughterGraphs=Function[{boundaryelement},
Block[{pmat,moduli,elementplanarity,pmstokeep,daughters},
pmat=boundaryelement[[1]];
moduli=boundaryelement[[2]];
elementplanarity=boundaryelement[[3]];
pmstokeep=Table[Flatten[Position[boundaryelement[[1]][[jjj]],0,1]],{jjj,Length[pmat]}];
daughters=Table[{DeleteCases[pmat[[All,Prepend[pmstokeep[[jjj]],1]]],Prepend[ConstantArray[0,Length[pmstokeep[[jjj]]]],_]],moduli[[All,pmstokeep[[jjj]]-1]],elementplanarity},{jjj,Length[pmstokeep]}];
daughters
]
];
(*After making allsubgraphs, we'll keep only those whose dimension has decreased by one. Furthermore, since we're unltimately only interested in reduced graphs, we'll remove those that are reducible. planarReducibility is able to take a planar case and tell you its reducibility very fast.*)
planarReducibility=Function[{pmatrix,modulispace},
Block[{pmatrixtranspose,modulitranspose,pmatrixshort,reducib},
If[pmatrix==={},
reducib=True;
,pmatrixtranspose=Transpose[pmatrix];
If[modulispace==={},modulitranspose=Table[{0},Length[pmatrixtranspose]];,modulitranspose=Transpose[modulispace];];
pmatrixshort=Transpose[Map[Times@@pmatrixtranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[pmatrixshort,ConstantArray[0,Dimensions[pmatrixshort][[2]]]],reducib=True;,reducib=False;];];
reducib]
];
(*Now we'll go through each level, starting from the top-dimensional one and working our way down, and first contruct the face lattice, and then remove those elements which are reducible.*)
(*Sometimes a level only contains reducible boundaries. In these cases we'll eliminate the reducible examples in a second step*)
(*We'll start by assessing the reducibility of the starting point. If it's planar, we may use the fast way. Otherwise we'll need to use the dimension of the Grassmannian.*)
If[BFTgraph||startingplanarity,
If[planarReducibility[Drop[removable[0][[1,1]],None,{1}],removable[0][[1,2]]]===False,
tofixlevels={};
,tofixlevels={0};
];
,If[dimensionGrassmannian[topleft,topright,bottomleft,bottomright]===topdim,
tofixlevels={};
,tofixlevels={0};
];
];
(*We will only evaluate the Grassmannian dimension of those nonplanar diagrams that have a chance of not being reducible.*)
maxnonplanardimension=topdim;
For[level=1,level<=topdim,level++,
(*For each element in removable[level-1] we make all subgraphs. We'll end up with many duplicates. Since they all inherit their planarity, some subgraphs are simultaneously labelled planar=True as well as planar=False. If any of these labels is True, then the graph has come from a planar one and must hence be planar. If it's still labelled non-planar, we'll later use planarityQ to check whether this is still the case.*)
removable[level]=Map[{#[[1,1]],#[[1,2]],Or@@Map[Last,#]}&,GatherBy[Table[Sequence@@makeDaughterGraphs[removable[level-1][[iii]]],{iii,Length[removable[level-1]]}],First]];
(*Now we'll remove those elements whose dimension has decreased by too much*)
removable[level]=Cases[removable[level],zz_/;polytopeDim[Drop[zz[[1]],None,{1}]]===topdim-level];
(*On the surviving elements, we'll reassess planarity on the nonplanar cases.*)
nonplanarpositions=Flatten[Position[removable[level],{___,False}]];
templevel=removable[level];
(*Now we'll take the nonplanar cases and check whether they really are still nonplanar. Begin by turning each of these cases into a list of killed edges.*)
boundarykillededges=Map[#->0&,Map[Complement[varlist,#[[1,All,1]]]&,removable[level][[nonplanarpositions]]],{2}];
newplanarity=Map[planarityQ[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges];
templevel[[nonplanarpositions,3]]=newplanarity;
(*Now we know for sure that the planarity labelling is correct*)
(*We'll now want to only keep reduced elements. For planar cases, planarReducibility is very fast at deterining this. For nonplanar cases, we'll need to check whether the dimension of the Grassmannian is the same as that of P. If not, it means we have secretly reduced the dimension of the Grassmannian too much by creating a reducible graph.*)
planarpositions=Flatten[Position[templevel,{___,True}]];
nonplanarpositions=Flatten[Position[templevel,{___,False}]];
(*We'll put the reduced planar elements first, then the reduced non-planar ones*)
planarboundaries=Cases[templevel[[planarpositions]],zz_/;planarReducibility[Drop[zz[[1]],None,{1}],zz[[2]]]===False];
(*For the nonplanar boundaries we'll need to evluate the dimension of the Grassmannian. However, if at level=1 we already found that all nonplanar diagrams had at most dim(Grassmannian), the nonplanar diagrams at this level will not have a higher dimension than that. Hence, if that dimension is less than topdim-level, we do not even need to bother evaluating the Grassmannian*)
If[maxnonplanardimension>=topdim-level,
nonplanarboundaries=templevel[[nonplanarpositions]][[Flatten[Position[Map[dimensionGrassmannian[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges[[Flatten[Position[newplanarity,False]]]]],topdim-level]]]];
,nonplanarboundaries={};
];
removable[level]=Join[planarboundaries,nonplanarboundaries];
If[removable[level]==={},
(*If some level happens to only contain reducible examples, we'll keep all boundaries, and remove the reducible ones later.*)
removable[level]=templevel;
tofixlevels=Append[tofixlevels,level];
(*If we are the at the first level and there were no reduced boundaries, find out what the maximal dimension of the Grassmannian is for nonplanar diagrams, so that we don't need to evaluate it again until topdim-level is equal to this Grassmannian dimension.*)
If[level==1,
maxnonplanardimension=Max[Map[dimensionGrassmannian[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges[[Flatten[Position[newplanarity,False]]]]]];
];
];
];
For[fix=1,fix<=Length[tofixlevels],fix++,
removable[tofixlevels[[fix]]]={};
];
(*Now we'll identify boundaries according to their substratification. From each element, it's sufficient to check the substratification one level down, since everything below that has been vetted by this first substratification level. At the bottom level (zero-dimensional) we can identify everything according to their moduli space.*)
identremovable[topdim]=Map[#[[1,All,1]]&,GatherBy[removable[topdim],#[[2]]&],{2}];
(*In order to compute the substratifications in a fast way, we'll check which boundaries of one dimension higher have these as subsets. We can do this by writing 0-dim boundaries as {___,edge1,___,edge2,__...} and check which boundaries of one dimension high fit this pattern*)
patternidentremovable[topdim]=Map[Alternatives@@#&,Map[Riffle[#,___,{1,-1,2}]&,identremovable[topdim],{2}]];
(*We'll now go through each of the dimensions, starting from the bottom*)
If[BFTgraph||startingplanarity,
(*We can identify everything according to its moduli space*)
For[dim=1,dim<topdim,dim++,
identremovable[topdim-dim]=Map[#[[1,All,1]]&,GatherBy[removable[topdim-dim],Sort[DeleteDuplicates[Transpose[#[[2]]]]]&],{2}];
];
,(*we'll need to identify according to the substratifications*)
For[dim=1,dim<topdim,dim++,
(*Begin by turning the boundaries into lists of edges*)
removable[topdim-dim]=Map[#[[1,All,1]]&,removable[topdim-dim]];
(*For each of the sub-boundaries, we want to find which graphs of one dimension higher terminate in this sub-boundary*)
locationofparents=Map[Flatten[Position[removable[topdim-dim],#]]&,patternidentremovable[topdim-dim+1]];
(*In each of the elements in removable[topdim-dim], we now want to know where they are in the list of locationofparents.*)
(*Since locationofparents indexes according to position, we'll turn removable[topdim-dim] into positions first.*)
thislevelspositions=Range[Length[removable[topdim-dim]]];
identremovable[topdim-dim]=Map[removable[topdim-dim][[#]]&,GatherBy[thislevelspositions,Position[locationofparents,{___,#,___}]&],{2}];
(*Now we're ready to do the same thing for the next dimension, and will need patternidentremovable for this dimension*)
patternidentremovable[topdim-dim]=Map[Alternatives@@#&,Map[Riffle[#,___,{1,-1,2}]&,identremovable[topdim-dim],{2}]];
];
];
(*Finally, the top-dimensional level is simply the list of edges in the starting point*)
identremovable[0]=Map[{#[[1,All,1]]}&,removable[0]];
(*The stratification will be outputted as a list of elements, each containing all the boundaries of a certain dimensionality. Each boundary is expressed as a list of possible non-zero edges which are move-equivalent configurations, all representing the same boundary.*)
stratification=Table[identremovable[iii],{iii,0,topdim}];
];
,stratification=Null;
];
stratification
];

getStratificationNumbers[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{checkOK,stratification,stratificationnumbers},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
stratification=getStratification[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
stratificationnumbers=Map[Length,stratification];
,stratificationnumbers=Null;
];
stratificationnumbers
];

getEulerNumber[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{checkOK,eulernumber,stratificationnumbers},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
stratificationnumbers=getStratificationNumbers[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph,gauging];
eulernumber=Sum[Power[(-1),iii+1]stratificationnumbers[[-iii]],{iii,Length[stratificationnumbers]}];
,eulernumber=Null;
];
eulernumber
];

getFaceLattice[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=Block[{checkOK,xlistandPmatrix,facelatticeboundaries,topdim,makeDaughterGraphs,level,facelattice},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
(*Each element in the face lattice of the matching polytope will be described by the perfect matching matrix P. This will allow us to construct the face lattice while computing the perfect matchings and matrix P as few times as possible (not once per subgraph!)*)
(*We'll start with making the top-dimensional element. In P we shall also tag on which edges correspond to each row, by making the first element of each row the edge name*)
xlistandPmatrix=Join[Transpose[{Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]}],getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph],2];
(*This will be the top-dimensional element in our stratification*)
facelatticeboundaries[0]={xlistandPmatrix};
(*We'll save some basic information to avoid having to evaluate it many times*)
topdim=polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]];
(*For each element in the face lattice, we will need to find all of its boundaries. These are found by deleting edges. makeDaughterGraphs takes an element in the face lattice and removes all possible edges, making potential boundaries (which will need to be verified)*)
makeDaughterGraphs=Function[{boundaryelement},
Block[{pmat,pmstokeep,daughters},
pmat=boundaryelement;
pmstokeep=Table[Flatten[Position[boundaryelement[[jjj]],0,1]],{jjj,Length[pmat]}];
daughters=Table[DeleteCases[pmat[[All,Prepend[pmstokeep[[jjj]],1]]],Prepend[ConstantArray[0,Length[pmstokeep[[jjj]]]],_]],{jjj,Length[pmstokeep]}];
daughters
]
];
(*After making allsubgraphs, we'll keep only those whose dimension has decreased by one.*)
For[level=1,level<=topdim,level++,
(*For each element in removable[level-1] we make all subgraphs. We'll end up with many duplicates*)
facelatticeboundaries[level]=DeleteDuplicates[Table[Sequence@@makeDaughterGraphs[facelatticeboundaries[level-1][[iii]]],{iii,Length[facelatticeboundaries[level-1]]}]];
(*Now we'll remove those elements whose dimension has decreased by too much*)
facelatticeboundaries[level]=Cases[facelatticeboundaries[level],zz_/;polytopeDim[Drop[zz,None,{1}]]===topdim-level];
];
facelatticeboundaries[topdim]=DeleteCases[facelatticeboundaries[topdim],{}];
facelattice=Map[#[[All,1]]&,Table[facelatticeboundaries[iii],{iii,0,topdim}],{2}];
,facelattice=Null;
];
facelattice
];

getStratificationGraph[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False,gauging_:2]/;(gauging===1&&BFTgraph===True||gauging===2):=Block[{checkOK,stratificationgraph,xlistandPmatrix,modulispace,startingplanarity,removable,topdim,varlist,makeDaughterGraphs,planarReducibility,tofixlevels,maxnonplanardimension,level,nonplanarpositions,templevel,boundarykillededges,newplanarity,planarpositions,planarboundaries,nonplanarboundaries,fix,identremovable,patternidentremovable,dim,locationofparents,thislevelspositions,identifiedboundaries,newlayer,alllayers,totalnumberofboundaries,tochangeposition,tokeeprowsandcolumns,adjacencymatrix},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
(*We begin by making the face lattice of the matching polytope. Each element in the face lattice will be composed of three objects: the perfect matching matrix P, the moduli space/matroid polytope, and the answer to planarityQ. This will allow us to construct the face lattice while computing the perfect matchings and matrix P as few times as possible (not once per subgraph!)*)
(*We'll start with making the top-dimensional element. In P we shall also tag on which edges correspond to each row, by making the first element of each row the edge name*)
If[Dimensions[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]][[2]]===0,
stratificationgraph=AdjacencyGraph[{}];
,xlistandPmatrix=Join[Transpose[{Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]}],getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph],2];
modulispace=moduliSpaceBFT[topleft,topright,bottomleft,bottomright,gauging,checkneeded,BFTgraph];
(*This will be the top-dimensional element in our stratification*)
startingplanarity=planarityQ[topleft,topright,bottomleft,bottomright];
If[BFTgraph||startingplanarity,
removable[0]={{xlistandPmatrix,modulispace,True}};
(*Since planarity is inherited by subgraphs, this means we'll never have to assess planarity again and we can treat everything as planar. This will mean we can assess reducibility very fast and easily, and identify everything according to their moduli space.*)
,removable[0]={{xlistandPmatrix,modulispace,startingplanarity}};
];
(*We'll save some basic information to avoid having to evaluate it many times*)
topdim=polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]];
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
(*For each element in the face lattice, we will need to find all of its boundaries. These are found by deleting edges. makeDaughterGraphs takes an element in the face lattice and removes all possible edges, making potential boundaries (which will need to be verified). Initially the planarity of the subgraphs is inherited, i.e. is declared equal to the originating graph.*)
makeDaughterGraphs=Function[{boundaryelement},
Block[{pmat,moduli,elementplanarity,pmstokeep,daughters},
pmat=boundaryelement[[1]];
moduli=boundaryelement[[2]];
elementplanarity=boundaryelement[[3]];
pmstokeep=Table[Flatten[Position[boundaryelement[[1]][[jjj]],0,1]],{jjj,Length[pmat]}];
daughters=Table[{DeleteCases[pmat[[All,Prepend[pmstokeep[[jjj]],1]]],Prepend[ConstantArray[0,Length[pmstokeep[[jjj]]]],_]],moduli[[All,pmstokeep[[jjj]]-1]],elementplanarity},{jjj,Length[pmstokeep]}];
daughters
]
];
(*After making allsubgraphs, we'll keep only those whose dimension has decreased by one. Furthermore, since we're unltimately only interested in reduced graphs, we'll remove those that are reducible. planarReducibility is able to take a planar case and tell you its reducibility very fast.*)
planarReducibility=Function[{pmatrix,modulispace},
Block[{pmatrixtranspose,modulitranspose,pmatrixshort,reducib},
If[pmatrix==={},
reducib=True;
,pmatrixtranspose=Transpose[pmatrix];
If[modulispace==={},modulitranspose=Table[{0},Length[pmatrixtranspose]];,modulitranspose=Transpose[modulispace];];
pmatrixshort=Transpose[Map[Times@@pmatrixtranspose[[Flatten[Position[modulitranspose,#]]]]&,DeleteDuplicates[modulitranspose]]];
If[MemberQ[pmatrixshort,ConstantArray[0,Dimensions[pmatrixshort][[2]]]],reducib=True;,reducib=False;];];
reducib]
];
(*Now we'll go through each level, starting from the top-dimensional one and working our way down, and first contruct the face lattice, and then remove those elements which are reducible.*)
(*Sometimes a level only contains reducible boundaries. In these cases we'll eliminate the reducible examples in a second step*)
(*We'll start by assessing the reducibility of the starting point. If it's planar, we may use the fast way. Otherwise we'll need to use the dimension of the Grassmannian.*)
If[BFTgraph,
If[planarReducibility[Drop[removable[0][[1,1]],None,{1}],removable[0][[1,2]]]===False,
tofixlevels={};
,tofixlevels={0};
];
,If[dimensionGrassmannian[topleft,topright,bottomleft,bottomright]===topdim,
tofixlevels={};
,tofixlevels={0};
];
];
(*We will only evaluate the Grassmannian dimension of those nonplanar diagrams that have a chance of not being reducible.*)
maxnonplanardimension=topdim;
For[level=1,level<=topdim,level++,
(*For each element in removable[level-1] we make all subgraphs. We'll end up with many duplicates. Since they all inherit their planarity, some subgraphs are simultaneously labelled planar=True as well as planar=False. If any of these labels is True, then the graph has come from a planar one and must hence be planar. If it's still labelled non-planar, we'll later use planarityQ to check whether this is still the case.*)
removable[level]=Map[{#[[1,1]],#[[1,2]],Or@@Map[Last,#]}&,GatherBy[Table[Sequence@@makeDaughterGraphs[removable[level-1][[iii]]],{iii,Length[removable[level-1]]}],First]];
(*Now we'll remove those elements whose dimension has decreased by too much*)
removable[level]=Cases[removable[level],zz_/;polytopeDim[Drop[zz[[1]],None,{1}]]===topdim-level];
(*On the surviving elements, we'll reassess planarity on the nonplanar cases.*)
nonplanarpositions=Flatten[Position[removable[level],{___,False}]];
templevel=removable[level];
(*Now we'll take the nonplanar cases and check whether they really are still nonplanar. Begin by turning each of these cases into a list of killed edges.*)
boundarykillededges=Map[#->0&,Map[Complement[varlist,#[[1,All,1]]]&,removable[level][[nonplanarpositions]]],{2}];
newplanarity=Map[planarityQ[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges];
templevel[[nonplanarpositions,3]]=newplanarity;
(*Now we know for sure that the planarity labelling is correct*)
(*We'll now want to only keep reduced elements. For planar cases, planarReducibility is very fast at deterining this. For nonplanar cases, we'll need to check whether the dimension of the Grassmannian is the same as that of P. If not, it means we have secretly reduced the dimension of the Grassmannian too much by creating a reducible graph.*)
planarpositions=Flatten[Position[templevel,{___,True}]];
nonplanarpositions=Flatten[Position[templevel,{___,False}]];
(*We'll put the reduced planar elements first, then the reduced non-planar ones*)
planarboundaries=Cases[templevel[[planarpositions]],zz_/;planarReducibility[Drop[zz[[1]],None,{1}],zz[[2]]]===False];
(*For the nonplanar boundaries we'll need to evluate the dimension of the Grassmannian. However, if at level=1 we already found that all nonplanar diagrams had at most dim(Grassmannian), the nonplanar diagrams at this level will not have a higher dimension than that. Hence, if that dimension is less than topdim-level, we do not even need to bother evaluating the Grassmannian*)
If[maxnonplanardimension>=topdim-level,
nonplanarboundaries=templevel[[nonplanarpositions]][[Flatten[Position[Map[dimensionGrassmannian[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges[[Flatten[Position[newplanarity,False]]]]],topdim-level]]]];
,nonplanarboundaries={};
];
removable[level]=Join[planarboundaries,nonplanarboundaries];
If[removable[level]==={},
(*If some level happens to only contain reducible examples, we'll keep all boundaries, and remove the reducible ones later.*)
removable[level]=templevel;
tofixlevels=Append[tofixlevels,level];
(*If we are the at the first level and there were no reduced boundaries, find out what the maximal dimension of the Grassmannian is for nonplanar diagrams, so that we don't need to evaluate it again until topdim-level is equal to this Grassmannian dimension.*)
If[level==1,
maxnonplanardimension=Max[Map[dimensionGrassmannian[topleft/.#,topright/.#,bottomleft/.#,bottomright]&,boundarykillededges[[Flatten[Position[newplanarity,False]]]]]];
];
];
];
For[fix=1,fix<=Length[tofixlevels],fix++,
removable[tofixlevels[[fix]]]={};
];
(*Now we'll identify boundaries according to their substratification. From each element, it's sufficient to check the substratification one level down, since everything below that has been vetted by this first substratification level. At the bottom level (zero-dimensional) we can identify everything according to their moduli space.*)
identremovable[topdim]=Map[#[[1,All,1]]&,GatherBy[removable[topdim],#[[2]]&],{2}];
(*In order to compute the substratifications in a fast way, we'll check which boundaries of one dimension higher have these as subsets. We can do this by writing 0-dim boundaries as {___,edge1,___,edge2,__...} and check which boundaries of one dimension high fit this pattern*)
patternidentremovable[topdim]=Map[Alternatives@@#&,Map[Riffle[#,___,{1,-1,2}]&,identremovable[topdim],{2}]];
(*We'll go through each dimension. When we find the connectivity between the various dimensions, we'll store it in an adjacencymatrix format. At then end we'll turn this information into a stratification graph.*)
For[dim=1,dim<=topdim,dim++,
If[BFTgraph||startingplanarity,
thislevelspositions=Range[Length[removable[topdim-dim]]];
identifiedboundaries=GatherBy[thislevelspositions,Sort[DeleteDuplicates[Transpose[removable[topdim-dim][[#]][[2]]]]]&];
removable[topdim-dim]=Map[#[[1,All,1]]&,removable[topdim-dim]];
locationofparents=Map[Flatten[Position[removable[topdim-dim],#]]&,patternidentremovable[topdim-dim+1]];
,(*Begin by turning the boundaries into lists of edges*)
removable[topdim-dim]=Map[#[[1,All,1]]&,removable[topdim-dim]];
(*For each of the sub-boundaries, we want to find which graphs of one dimension higher terminate in this sub-boundary*)
locationofparents=Map[Flatten[Position[removable[topdim-dim],#]]&,patternidentremovable[topdim-dim+1]];
(*In each of the elements in removable[topdim-dim], we now want to know where they are in the list of locationofparents.*)
(*Since locationofparents indexes according to position, we'll turn removable[topdim-dim] into positions first.*)
thislevelspositions=Range[Length[removable[topdim-dim]]];
identifiedboundaries=GatherBy[thislevelspositions,Position[locationofparents,{___,#,___}]&];
];
identremovable[topdim-dim]=Map[removable[topdim-dim][[#]]&,identifiedboundaries,{2}];
(*Now we're ready to do the same thing for the next dimension, and will need patternidentremovable for this dimension*)
patternidentremovable[topdim-dim]=Map[Alternatives@@#&,Map[Riffle[#,___,{1,-1,2}]&,identremovable[topdim-dim],{2}]];
(*Now we'll make a matrix with rows corresponding to boundaries in removable[topdim-dim] and columns corresponding to boundaries in identremovable[topdim-dim+1]. If an object in removable[topdim-dim] can access a subboundary in identremovable[topdim-dim+1] that entry has a 1, otherwise it is 0.*)
(*The levels that contain no boundaries cause difficulties. Every time this happens, we'll place a fake boundary there with no connectivity to any other boundaries. When we've finished constructing the final adjacency matrix we'll throw away these fake boundaries.*)
If[Length[identremovable[topdim-dim]]===0&&Length[locationofparents]===0,
(*If the current level is empty and so is the next, create an isolated node with no connectivity*)
newlayer[dim]={{0}};
,If[Length[identremovable[topdim-dim]]===0&&Length[locationofparents]=!=0,
(*If the current level is empty but the next one is not, create a temporary node (with no connectivity)*)
newlayer[dim]=Table[0,{iii,1},{jjj,Length[locationofparents]}];
,If[Length[identremovable[topdim-dim]]=!=0&&Length[locationofparents]===0,
(*If the current level is not empty but the one beneath it is, create zero adjacency to the temporary node sitting at the empty level*)
newlayer[dim]=Table[0,{iii,Length[identremovable[topdim-dim]]},{jjj,1}];
,If[Length[identremovable[topdim-dim]]=!=0&&Length[locationofparents]=!=0,
(*If we have boundaries going to other boundaries, make the correct connectivity matrix*)
newlayer[dim]=Normal[SparseArray[Map[#->1&,MapThread[Sequence@@Transpose[{#1,ConstantArray[#2,Length[#1]]}]&,{locationofparents,Range[Length[locationofparents]]}]]]];
(*If there are some elements that are not connected with lower-dim boundaries, we need to make sure that we have the right number of (empty) rows and columns.*)
newlayer[dim]=PadRight[newlayer[dim],{Length[removable[topdim-dim]],Length[locationofparents]}];
(*After the identifications many objects in removable[topdim-dim] are declared to be the same. We'll therefore only select one representative from each such equivalence class of graphs. Since for scattering amplitudes all equivalence classes of graphs have the same subboundaries, we can just pick one of the graphs. For BFTs we'll have to create an object which has connectivity to any subgraphs accessible from this equivalence class.*)
If[BFTgraph,
newlayer[dim]=Map[Total,Map[newlayer[dim][[#]]&,identifiedboundaries,{2}]]/.{_?Positive->1};
,newlayer[dim]=newlayer[dim][[Complement[Range[Length[removable[topdim-dim]]],Map[Sequence@@Delete[#,1]&,identifiedboundaries]]]];
];
];
];
];
];
];
alllayers=Reverse[Table[newlayer[iii],{iii,1,topdim}]];
(*In the highest-dimensional non-zero layer, we have the top-dimensional elements going to the codimension-1 elements. Since the top-dim elements are not connected to themselves in the stratification, we must add some zeros in front of newlayer[xxx] so that the adjacency matrix is correct.*)
If[Length[alllayers]>0,
alllayers[[1]]=Join[Table[0,{iii,Length[alllayers[[1]]]},{jjj,Length[alllayers[[1]]]}],alllayers[[1]],2];
];
totalnumberofboundaries=Total[Map[Dimensions[#][[2]]&,alllayers]];
(*We need to throw away those boundaries that correspond to fake temporary nodes*)
tokeeprowsandcolumns=Complement[Range[totalnumberofboundaries],Accumulate[Map[Dimensions[#][[1]]&,alllayers]][[tofixlevels+1]]];
adjacencymatrix=Normal[SparseArray[Band[{1,1}]->alllayers,{totalnumberofboundaries,totalnumberofboundaries}]][[tokeeprowsandcolumns,tokeeprowsandcolumns]];
stratificationgraph=AdjacencyGraph[adjacencymatrix];
];
,stratificationgraph=Null;
];
stratificationgraph
];

getFaceLatticeGraph[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=Block[{checkOK,xlistandPmatrix,facelatticeboundaries,topdim,makeDaughterGraphs,level,patternfacelatticeboundaries,locationofparents,newlayer,alllayers,totalnumberofboundaries,stratificationgraph},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph];
];
If[checkOK==True,
(*Each element in the face lattice of the matching polytope will be described by the perfect matching matrix P. This will allow us to construct the face lattice while computing the perfect matchings and matrix P as few times as possible (not once per subgraph!)*)
(*We'll start with making the top-dimensional element. In P we shall also tag on which edges correspond to each row, by making the first element of each row the edge name*)
If[Dimensions[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]][[2]]===0,
stratificationgraph=AdjacencyGraph[{}];
,xlistandPmatrix=Join[Transpose[{Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]]}],getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph],2];
(*This will be the top-dimensional element in our stratification*)
facelatticeboundaries[0]={xlistandPmatrix};
(*We'll save some basic information to avoid having to evaluate it many times*)
topdim=polytopeDim[getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]];
(*For each element in the face lattice, we will need to find all of its boundaries. These are found by deleting edges. makeDaughterGraphs takes an element in the face lattice and removes all possible edges, making potential boundaries (which will need to be verified)*)
makeDaughterGraphs=Function[{boundaryelement},
Block[{pmat,pmstokeep,daughters},
pmat=boundaryelement;
pmstokeep=Table[Flatten[Position[boundaryelement[[jjj]],0,1]],{jjj,Length[pmat]}];
daughters=Table[DeleteCases[pmat[[All,Prepend[pmstokeep[[jjj]],1]]],Prepend[ConstantArray[0,Length[pmstokeep[[jjj]]]],_]],{jjj,Length[pmstokeep]}];
daughters
]
];
(*After making allsubgraphs, we'll keep only those whose dimension has decreased by one.*)
For[level=1,level<=topdim,level++,
(*For each element in removable[level-1] we make all subgraphs. We'll end up with many duplicates*)
facelatticeboundaries[level]=DeleteDuplicates[Table[Sequence@@makeDaughterGraphs[facelatticeboundaries[level-1][[iii]]],{iii,Length[facelatticeboundaries[level-1]]}]];
(*Now we'll remove those elements whose dimension has decreased by too much*)
facelatticeboundaries[level]=Cases[facelatticeboundaries[level],zz_/;polytopeDim[Drop[zz,None,{1}]]===topdim-level];
];
facelatticeboundaries[topdim]=DeleteCases[facelatticeboundaries[topdim],{}];
facelatticeboundaries[0]=Map[#[[All,1]]&,facelatticeboundaries[0]];
(*We'll go through each level of the stratification. When we find the connectivity between the various dimensions, we'll store it in an adjacencymatrix format. At then end we'll turn this information into a stratification graph.*)
For[level=1,level<=topdim,level++,
(*Begin by turning the boundaries into lists of edges*)
facelatticeboundaries[level]=Map[#[[All,1]]&,facelatticeboundaries[level]];
(*For each of the sub-boundaries, we want to find which graphs of one dimension higher terminate in this sub-boundary*)
(*In order to compute the substratifications in a fast way, we'll check which boundaries of one dimension higher have these as subsets. We can do this by writing 0-dim boundaries as {___,edge1,___,edge2,__...} and check which boundaries of one dimension high fit this pattern*)
patternfacelatticeboundaries[level]=Map[Riffle[#,___,{1,-1,2}]&,facelatticeboundaries[level]];
(*In each of the elements in removable[topdim-dim], we now want to know where they are in the list of locationofparents.*)
locationofparents=Map[Flatten[Position[facelatticeboundaries[level-1],#]]&,patternfacelatticeboundaries[level]];
(*Now we'll make a matrix with rows corresponding to boundaries in removable[topdim-dim] and columns corresponding to boundaries in identremovable[topdim-dim+1]. If an object in removable[topdim-dim] can access a subboundary in identremovable[topdim-dim+1] that entry has a 1, otherwise it is 0.*)
newlayer[level]=Normal[SparseArray[Map[#->1&,MapThread[Sequence@@Transpose[{#1,ConstantArray[#2,Length[#1]]}]&,{locationofparents,Range[Length[locationofparents]]}]]]];
];
newlayer[1]=Join[Table[0,{iii,Length[newlayer[1]]},{jjj,Length[newlayer[1]]}],newlayer[1],2];
alllayers=Table[newlayer[iii],{iii,1,topdim}];
totalnumberofboundaries=Total[Map[Dimensions[#][[2]]&,alllayers]];
stratificationgraph=AdjacencyGraph[Normal[SparseArray[Band[{1,1}]->alllayers,{totalnumberofboundaries,totalnumberofboundaries}]]];
];
,stratificationgraph=Null;
];
stratificationgraph
];

nonTrivialPoles[topleft_,topright_,bottomleft_,bottomright_,sizeofrelation_]:=Module[{pathmat,minorintermsofedges,positionzerominors,allminors,nonzerominors,allorderrelations,minorstotheirexpression,positionsatisfiedrelations,pluckerRelSolution,solutiontopluckerrelations,assumptions,potentialsecretrelations,pospluckerrelations,nontrivialcleanrelations,secretrelationssolutions,turnIntoCleanRelation,secretrelations},
(*In order to find all nonstandard poles, we'll start by creating all possible operators of a given size='sizeofrelation', e.g. sizeofrelation=3 gives operators of type (Plucker Plucker Plucker)\[Equal](Plucker Plucker Plucker). We'll then replace the Pluckers by their actual expressions in terms of edge variables. In general, many of these operators will trivially be equal to zero after this step. We'll then find out which of these follow from the Plucker relations and which are genuinely new.*)
(*We'll begin by obtaining the path matrix, which in turn gives the expressions of the minors*)
If[planarityQ[topleft,topright,bottomleft,bottomright],
secretrelations={{}};
,pathmat=pathMatrix[topleft,topright,bottomleft,bottomright];
minorintermsofedges=Minors[pathmat,Length[pathmat]][[1]];
(*We don't need to look for relations that contain minors which are trivially zero. We'll therefore find out which minors are nonzero*)
positionzerominors=Position[minorintermsofedges,0];
allminors=Map[HoldForm[minor][Sequence@@#]&,Subsets[Range[Dimensions[pathmat][[2]]],{Length[pathmat]}]];
nonzerominors=Delete[allminors,positionzerominors];
(*We'll now make all the possible relations between the Pluckers. We do this by first making operaors of size 1, i.e. Plucker=Plucker, then size 2, etc. up to size=sizeofrelation. Often (Plucker Plucker Plucker)\[Equal](Plucker Plucker Plucker) simplifies to (Plucker Plucker)\[Equal](Plucker Plucker), which we already had included. We therefore remove these relations with duplicate minors.*)
allorderrelations=Map[(#[[1]]-#[[2]]==0)&,Map[Times@@#&,DeleteCases[Table[Sequence@@Subsets[Subsets[nonzerominors,{iii}],{2}],{iii,sizeofrelation}],{{___,duplminor_,___},{___,duplminor_,___}}],{2}]];
(*We have all possible operators. We'll now find out which of these is satisfied by our current configuration (this may take a while)*)
minorstotheirexpression=Delete[MapThread[Rule,{allminors,minorintermsofedges}],positionzerominors];
positionsatisfiedrelations=Position[Map[Expand[#/.minorstotheirexpression]===True&,allorderrelations],True];
(*Now we need to find out which of these follow from the Plucker relations. pluckerRelSolution gives the solution to the plucker relations for k & n when we have shut off certain minors.*)
pluckerRelSolution=Function[{k,n,listofzerominors},
Block[{tozerorule,pluckerrel,solutions,independentrelations,newsolution,ii},
tozerorule=Map[#->0&,listofzerominors];
pluckerrel=DeleteCases[pluckerRelations[k,n]/.tozerorule,True];
solutions={};
If[pluckerrel=!={},
independentrelations=pluckerrel[[{1}]];(*this variable will contain all independent relations*)
newsolution=DeleteCases[Solve[And@@independentrelations],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];(*this variable will contain all independent solutions*)
(*Go through the remianing plucker relations. If the next Plucker relations is not triviliazied by the solutions we already found to the previous relations, add it to the list of independent relations, and solve it.*)
For[ii=2,ii<=Length[pluckerrel],ii++,
If[Simplify[pluckerrel[[ii]]//.solutions]=!=True,
independentrelations=Append[independentrelations,pluckerrel[[ii]]];
newsolution=DeleteCases[Solve[And@@Simplify[independentrelations//.solutions]],zz_/;MemberQ[zz,_->0]];
solutions=Join[solutions,newsolution[[1]]];
(*If we have found as many solutions as there are independent relations in total, stop here, since the remainigs Plucker relations cannot be independent*)
];
];
(*Tidy up the solutions so that they all depend on the same set of variables*)
solutions=MapThread[Rule,{Map[#[[1]]&,solutions],Simplify[Map[#[[2]]&,solutions]//.solutions]}];
];
solutions]
];
solutiontopluckerrelations=pluckerRelSolution[Length[pathmat],Dimensions[pathmat][[2]],allminors[[Flatten[positionzerominors]]]];
assumptions=And@@Map[#!=0&,nonzerominors];
(*Let's now mod out by the plucker relations by substituting in their solution*)
potentialsecretrelations=Map[Simplify[#/.solutiontopluckerrelations,assumptions]&,allorderrelations[[Flatten[positionsatisfiedrelations]]]];
(*We'll now remove those that are equal to plucker relations*)
pospluckerrelations=Position[potentialsecretrelations,True];
potentialsecretrelations=Delete[potentialsecretrelations,pospluckerrelations];
nontrivialcleanrelations=Delete[allorderrelations[[Flatten[positionsatisfiedrelations]]],pospluckerrelations];
(*Not all of these secret relations are independent. We'll find solutions that solve them all*)
If[potentialsecretrelations=!={},(*they are not all equal to plucker relations*)
secretrelationssolutions=Solve[(And@@potentialsecretrelations)&&assumptions];
(*We'll pick the least restrictive of the solutions*)
secretrelationssolutions=Cases[secretrelationssolutions,zz_/;Length[zz]==Min[Map[Length,secretrelationssolutions]]];
,(*we only have plucker relations*)
secretrelationssolutions={{}};
];
(*We now have (possibly multiple) solutions. We could just output these solutions, as they consistute operators vanishing that are independent of the plucker relations and of each other. But their form can look complicated, because we substituted in the solution to the plucker relations. Therefore, we'll turn each of these into its equuivalent form in allminors*)
turnIntoCleanRelation=Function[{listofreplacements},
Block[{remainingsecretrelations,remainingcleanrelations,outputcleanrelations,jj,relationsthattrivialize},
remainingsecretrelations=potentialsecretrelations;
remainingcleanrelations=nontrivialcleanrelations;
outputcleanrelations={};
For[jj=1,jj<=Length[listofreplacements],jj++,
relationsthattrivialize=Position[Simplify[remainingsecretrelations/.{listofreplacements[[jj]]}],True];
outputcleanrelations=Join[outputcleanrelations,remainingcleanrelations[[relationsthattrivialize[[1]]]]];
remainingsecretrelations=Delete[remainingsecretrelations,relationsthattrivialize];
remainingcleanrelations=Delete[remainingcleanrelations,relationsthattrivialize];
];
outputcleanrelations]
];
secretrelations=Map[turnIntoCleanRelation[#]&,secretrelationssolutions];
];
secretrelations
];


End[];
EndPackage[]
