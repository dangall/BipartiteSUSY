(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["BipartiteSUSY`"]

polytopeDim::usage="Takes a matrix as input and outputs the dimension of a polytope with vertices given the columns of that matrix"
joinupKasteleyn::usage="REMOVE ME FROM GLOBAL FUNCTIONS!"
totFaces::usage="Gives the TOTAL number of faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
externalFaces::usage="Gives the number of EXTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
internalFaces::usage="Gives the number of INTERNAL faces in the graph. Assumes that edges are of the form X[i,j], where i and j are face labels (faces must be labeled in numerical order)"
reducibilityQ::usage="Tells you whether a graph is reducible, in the scattering amplitudes sense. Set the last argument equal to True to get reducibility in the \!\(\*SubscriptBox[\(BFT\), \(2\)]\) sense"
getWeightedAdjacencyMatrix::usage="Gives the weighted adjacency matrix which can be used for WeightedAdjacencyGraph"
getAdjacencyMatrix::usage="Gives the adjacency matrix which can be used for AdjacencyGraph"
planarityQ::usage="Tells you whether a given graph can be embedded on the disk without any edges crossing"
viewGraph::usage="Shows you the graph"
duplicateEdges::usage="Returns a list of edges not appearing in a correct way in the Kasteleyn"
edgesBFTformQ::usage="Tells you whether edges are of the correct form _[_Integer,_Integer]"
consistentKasteleyn::usage="Assuming that edgesBFTformQ returns True, this function will return the list of rows and columns whose index structure violates the rules for BFTs (clockwise around white nodes and counter-clockwise around black nodes)"
checkKasteleynQ::usage="Tells you whether the Kasteleyn was inputted correctly. Its final input is optional and says whether the graph is a BFT graph (with corresponding index structure) or not."
perfectMatchings::usage="Returns the sorted list of perfect matchings. Takes as optional input whether it should check the Kasteleyn for you, and whether the graph is a BFT graph."
getPmatrix::usage="Returns the P matrix. Rows are ordered lexicographically w.r.t. edge labeling, columns are ordered according to the order given by the perfectMatchings function"
intoPolytope::usage="Returns only distinct vertices of the polytope, with their multiplicity"
matroidPolytope::usage="Returns the coordinates of the matroid polytope (some of which may have higher multiplicity than 1). Each column is the coordinate of a perfect matching."
moduliSpaceBFT::usage="Gives the moduli space of the BFT given by the Kasteleyn. It requires the input on which gauging it should use (i.e. gauging 1 or gauging 2)."

Begin["Private`"]


(*Basic functions that manipule and extract information from the Kasteleyn*)


joinupKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=joinupKasteleyn[topleft,topright,bottomleft,bottomright]=Join[Join[topleft,bottomleft],Join[topright,bottomright],2];

totFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,nf},
varlist=Variables[Join[topleft,topright,bottomleft,bottomright]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
nf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
nf=Null;
];
nf
];

externalFaces[topleft_,topright_,bottomleft_,bottomright_]:=Block[{varlist,facelist,externalnf},
varlist=Variables[Join[topright,bottomleft]];
(*If all variables are in the required format X[i,j], go ahead and count faces*)
If[Cases[varlist,_[_,_]]==varlist,
facelist=Union[Flatten[List@@@varlist]];
externalnf=Length[facelist];
,Print["Error! The edges must all have the form X[i,j] (where X may be any letter/letters)."];
externalnf=Null;
];
externalnf
];

internalFaces[topleft_,topright_,bottomleft_,bottomright_]:=totFaces[topleft,topright,bottomleft,bottomright]-externalFaces[topleft,topright,bottomleft,bottomright];


(*Functions useful for graph drawing and manipulation*)


getWeightedAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into a weightedadjaceny matrix*)
adjacencymatrix=Join[Join[ConstantArray[0,{Length[kasteleyn],Length[kasteleyn]}],Transpose[kasteleyn]],Join[kasteleyn,ConstantArray[0,{Dimensions[kasteleyn][[2]],Dimensions[kasteleyn][[2]]}]],2]/.{0->\[Infinity]};
adjacencymatrix
];

getAdjacencyMatrix[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymatrix},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We will now turn the kasteleyn into an adjaceny matrix*)
oneskasteleyn=kasteleyn/.Map[#->1&,Variables[kasteleyn]];
adjacencymatrix=Join[Join[ConstantArray[0,{Length[oneskasteleyn],Length[oneskasteleyn]}],Transpose[oneskasteleyn]],Join[oneskasteleyn,ConstantArray[0,{Dimensions[oneskasteleyn][[2]],Dimensions[oneskasteleyn][[2]]}]],2];
adjacencymatrix
];

viewGraph[topleft_,topright_,bottomleft_,bottomright_,showedges_:True]:=Module[{badedges,adjacencymat,kasteleyn,colors,graph,edgelist,vars,edgelabels,tempedgelabels,finalgraph,edgeweightname},
(*This needs to be a Module rather than Block, because otherwise my graph drawing at the end doesn't have access to the variable tempedgelabels!*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges==={},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*We'll now make the bipartite coloring for the nodes of the graph*)
colors=MapThread[Rule,{Range[Total[Dimensions[kasteleyn]]],Join[ConstantArray[White,Length[kasteleyn]],ConstantArray[Black,Dimensions[kasteleyn][[2]]]]}];
(*We'll now get the edge list (by making a temporary graph), and use this edge list to print names on all the edges of the graph. The difficulty is largely due to giving differnt names to multiple edges going between two nodes (i.e. bubbles).*)
If[showedges==True,
graph=AdjacencyGraph[adjacencymat];
edgelist=EdgeList[graph];
vars=Variables[kasteleyn];
edgelabels=Map[Sort[(UndirectedEdge@@(Flatten[Position[kasteleyn,#]][[{1,2}]]+{0,Length[kasteleyn]}))]->#&,vars];
(*Now that we associated edges to their names, we'll make a temporary list from which we'll remove elements as they get printed onto the graph*)
tempedgelabels=edgelabels;
finalgraph=Graph[edgelist,EdgeShapeFunction->Function[{edgepositions,edgename},
edgeweightname=tempedgelabels[[Position[tempedgelabels,Sort[edgename]][[1,1]],2]];
tempedgelabels=Delete[tempedgelabels,Position[tempedgelabels,Sort[edgename]][[1,1]]];
{Text[Style[edgeweightname,Medium,Bold,Blue],Mean[edgepositions]],{Black,Line[edgepositions]}}],VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
,finalgraph=AdjacencyGraph[adjacencymat,VertexLabels->"Name",VertexLabelStyle->15,VertexSize->Medium,VertexStyle->colors,ImagePadding->20];
];
finalgraph
,Print["The Kasteleyn has multiple fields with the same name - can't draw the graph."];
finalgraph=Null;
];
finalgraph
];


(*Functions to check the Kasteleyn*)


duplicateEdges[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,doubleslist,kasteleynterms},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Make a list of edges that appear twice*)
doubleslist=Variables[kasteleyn][[Flatten[Position[Map[Length[Position[kasteleyn,#]]&,Variables[kasteleyn]],z_/;z>1]]]];
(*Also look for edges appearing with a minus, or with prefactors different from 1*)
kasteleynterms=Flatten[Map[MonomialList,DeleteCases[Flatten[kasteleyn],0]]];
Sort[Join[doubleslist,Variables[Complement[kasteleynterms,Variables[kasteleynterms]]]]]
];

edgesBFTformQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn},
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[z1_,z2_]/;IntegerQ[z1]&&IntegerQ[z2]]]==={}*)
Complement[Variables[kasteleyn],Cases[Variables[kasteleyn],_[_Integer,_Integer]]]==={}
];

consistentKasteleyn[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,tocheck,rowsOK,columnsOK,consistencyviolation},
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],
kasteleyn=joinupKasteleyn[topleft,topright,bottomleft,bottomright];
(*First check the rows of the Kasteleyn matrix corresponding to internal white nodes*)
tocheck=kasteleyn[[Range[Length[topleft]]]];
rowsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
(*Now check the columns of the Kasteleyn matrix corresponding to internal black nodes*)
tocheck=Transpose[kasteleyn[[All,Range[Dimensions[topleft][[2]]]]]];
columnsOK=Map[(#[[1]]-#[[2]])===ConstantArray[0,Length[#[[1]]]]&,Map[Sort,Map[Transpose,Map[{#[[1]],#[[2]]}&,Map[Variables,tocheck],{2}]],{2}]];
consistencyviolation={Flatten[Position[rowsOK,False]],Flatten[Position[columnsOK,False]]};
,consistencyviolation=Null;
];
consistencyviolation
];

checkKasteleynQ[topleft_,topright_,bottomleft_,bottomright_,BFTgraph_]:=Block[{return,badedges,indexmistakes},
return=True;
(*First check that the field hasn't been entered in twice*)
badedges=duplicateEdges[topleft,topright,bottomleft,bottomright];
If[badedges=!={},
(*if there are obvious mistakes, write them out*)
return=False;
Print["Check Kasteleyn: edges ",badedges," appear incorrectly."];
,If[BFTgraph,(*if there are no obvious mistakes, do more checks if we have a BFT graph*)
If[edgesBFTformQ[topleft,topright,bottomleft,bottomright],(*if the edges have the correct structure _[_,_] check for index mistakes*)
indexmistakes=consistentKasteleyn[topleft,topright,bottomleft,bottomright];
If[indexmistakes=!={{},{}},(*if we have index mistakes, point them out*)
return=False;
Print["There appears to be a mistake in the index structure in rows ",indexmistakes[[1]]," of the Kasteleyn."];
Print["There appears to be a mistake in the index structure in columns ",indexmistakes[[2]]," of the Kasteleyn."];
];
,return=False;(*we have a BFT with no doubles, but whose fields are not all in the right form*)
Print["Some edges have not been inputted in the correct form of _[_Integer,_Integer]"];
];
];
];
return
];


(*General functions for bipartita analysis*)


perfectMatchings[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=perfectMatchings[topleft,topright,bottomleft,bottomright]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded]=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=Block[{checkOK,externalrows,externalcolumns,rowandcolumnnumbers,rowsmergedonleftandright,newtonpolynomial,perfectmatchigns,zz},
checkOK=True;
If[checkneeded==True,
checkOK=checkKasteleynQ[topleft,topright,bottomleft,bottomright,BFTgraph]
];
If[checkOK==True,
(*get all subsets of rows in bottomleft, and columns in topright*)
externalrows=Subsets[Range[Length[bottomleft]]];
externalcolumns=Subsets[Range[Length[Transpose[topright]]]];
(*Put these choices together, and only include those combinations that, when joined with topleft, leave a square matrix*)
rowandcolumnnumbers=Cases[Tuples[{externalrows,externalcolumns}],z_/;Equal@@(Map[Length,z]+Dimensions[topleft])];
(*For each case, merge topleft and the chosen rows of bottonleft. Also, merge the chosen columns of topright with the chosen columns and rows of bottomright.*)
rowsmergedonleftandright=Map[{Join[topleft,bottomleft[[#[[1]]]]],Join[topright[[All,#[[2]]]],bottomright[[#[[1]],#[[2]]]]]}&,rowandcolumnnumbers];
(*Now merge each case into a square matrix and compute its determinant. Then add up all the determinants.*)
newtonpolynomial=Total[Map[Det[Join[#[[1]],#[[2]],2]]&,rowsmergedonleftandright]];
(*Tidy up the signs, since perfect matchings are positive*)
perfectmatchigns=Sort[MonomialList[newtonpolynomial]/.{Times[-1,zz_]->Times[zz]}];
,perfectmatchigns=Null;
];
perfectmatchigns
];

getPmatrix[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*getPmatrix[topleft,topright,bottomleft,bottomright]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded]=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{varlist,plist,pmatrix},
varlist=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
plist=perfectMatchings[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[plist=!=Null,
pmatrix=Table[MemberQ[Variables[plist[[jjj]]],varlist[[iii]]],{iii,Length[varlist]},{jjj,Length[plist]}]/.{True->1,False->0};
,pmatrix=Null;
];
pmatrix
];

matroidPolytope[topleft_,topright_,bottomleft_,bottomright_,checkneeded_:False,BFTgraph_:False]:=(*matroidPolytope[topleft,topright,bottomleft,bottomright]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded]=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph]=*)Block[{pmatrix,externaledges,externalrows,matroidpoly},
pmatrix=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
If[pmatrix=!=Null,
(*Only select those rows corresponding to external edges in the graph*)
externaledges=Variables[Join[bottomleft,topright]];
externalrows=Flatten[Position[Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]],Alternatives@@externaledges]];
matroidpoly=pmatrix[[externalrows]];
,matroidpoly=Null;
];
matroidpoly
];

moduliSpaceBFT[topleft_,topright_,bottomleft_,bottomright_,gauging_,checkneeded_:False,BFTgraph_:False]/;(gauging===1||gauging===2):=Block[{modulispace,matrixP,chargesFterm,gaugeCharge,edges,intfaces,gaugechargematrix,chargesDterm},
If[gauging==2,
modulispace=matroidPolytope[topleft,topright,bottomleft,bottomright,checkneeded,BFTgraph];
,If[gauging==1,
(*gauging 1 only works for graphs of BFT type, i.e. where the edges are labeled according to the faces they touch*)
matrixP=getPmatrix[topleft,topright,bottomleft,bottomright,checkneeded,True];
If[matrixP=!=Null,
chargesFterm=NullSpace[matrixP];
gaugeCharge=Function[{edge,column},Block[{output=0},If[edge[[1]]==column,output=output+1;];If[edge[[2]]==column,output=output-1;];output]];
edges=Variables[joinupKasteleyn[topleft,topright,bottomleft,bottomright]];
intfaces=internalFaces[topleft,topright,bottomleft,bottomright];
gaugechargematrix=Table[gaugeCharge[edges[[iii]],jjj],{iii,Length[edges]},{jjj,intfaces}];
chargesDterm=Transpose[LinearSolve[matrixP,gaugechargematrix]];
modulispace=NullSpace[Join[chargesFterm,chargesDterm]];
,modulispace=Null;
];
];
];
modulispace
];

polytopeDim[mat_]:=Block[{dimension,newmat},
If[MemberQ[Transpose[mat],ConstantArray[0,Length[mat]]],
(*If the matrix has a column of zeros, the matrix rank gives you the dimension. Otherwise you need to shift the matrix so that a vertex is at the origin.*)
dimension=MatrixRank[mat];
,newmat=mat-mat[[All,1]];(*this operation automatically threads over all the columns of the matrix.*)
dimension=MatrixRank[newmat];
];
dimension
];

intoPolytope[mat_]:=Block[{columnsandmultiplicity,polytope,multiplicity},
columnsandmultiplicity=Tally[Transpose[mat]];
polytope=Transpose[Map[#[[1]]&,columnsandmultiplicity]];
multiplicity=Map[#[[2]]&,columnsandmultiplicity];
{polytope,multiplicity}
];



(*Functions useful for scattering amplitudes*)


planarityQ[topleft_,topright_,bottomleft_,bottomright_]:=Block[{kasteleyn,oneskasteleyn,adjacencymat,graph,planar,externals,extnum,permutations,externaladjacencyseed,externaladjencyattempts,ii,testgraph},
adjacencymat=getAdjacencyMatrix[topleft,topright,bottomleft,bottomright];
graph=AdjacencyGraph[adjacencymat];(*We have finished making the Mathematica graph!*)
(*If the graph can be embedded on genus zero, try and see if we can do so with only one boundary*)
planar=False;(*assume the graph is non-planar until proven otherwise*)
If[PlanarGraphQ[graph],
externals=Flatten[Position[Map[Total,adjacencymat],1]];(*These are the row-numbers corresponding to external nodes*)
extnum=Length[externals];
(*We will now try and form a single external boundary by connecting up all external nodes sequentially*)
permutations=Map[Append[#[[1]],extnum]&,Gather[Permutations[Range[extnum-1]],#1==Reverse[#2]&]];
(*We will start by making an adjacency matrix for one choice of external boundary. We will then permute this matrix in all possible ways*)
externaladjacencyseed=Normal[AdjacencyMatrix[PathGraph[Prepend[permutations[[1]],extnum]]]];
externaladjencyattempts=Map[externaladjacencyseed[[#,#]]&,permutations];
For[ii=1,ii<=Length[externaladjencyattempts],ii++,
adjacencymat[[externals,externals]]=externaladjencyattempts[[ii]];
testgraph=AdjacencyGraph[adjacencymat];
If[PlanarGraphQ[testgraph],
planar=True;
Break[];
];
];
];
planar
];


End[];
EndPackage[]
